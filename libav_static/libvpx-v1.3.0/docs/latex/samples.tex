This S\+D\+K includes a number of sample applications. each sample documents a feature of the S\+D\+K in both prose and the associated C code. In general, later samples build upon prior samples, so it is best to work through the list in order. The following samples are included\+:
\begin{DoxyItemize}
\item \hyperlink{example_simple_decoder}{simple\+\_\+decoder.\+c} Simplified decoder loop
\item \hyperlink{example_postproc}{postproc.\+c} Decoder postprocessor control
\item \hyperlink{example_decode_to_md5}{decode\+\_\+to\+\_\+md5.\+c} Frame by frame M\+D5 checksum
\item \hyperlink{example_simple_encoder}{simple\+\_\+encoder.\+c} Simplified encoder loop
\item \hyperlink{example_twopass_encoder}{twopass\+\_\+encoder.\+c} Two-\/pass encoder loop
\item \hyperlink{example_force_keyframe}{force\+\_\+keyframe.\+c} Force generation of keyframes
\item \hyperlink{example_decode_with_drops}{decode\+\_\+with\+\_\+drops.\+c} Drops frames while decoding
\item \hyperlink{example_error_resilient}{error\+\_\+resilient.\+c} Error Resiliency Feature
\item \hyperlink{example_vp8_set_maps}{vp8\+\_\+set\+\_\+maps.\+c} V\+P8 set active and R\+O\+I maps
\item \hyperlink{example_vp8cx_set_ref}{vp8cx\+\_\+set\+\_\+ref.\+c} V\+P8 set encoder reference frame
\end{DoxyItemize}

In addition, the S\+D\+K contains a number of utilities. Since these utilities are built upon the concepts described in the sample code listed above, they are not documented in pieces like the samples are. Thir sourcre is included here for reference. The following utilities are included\+:
\begin{DoxyItemize}
\item \hyperlink{example_vpxdec}{vpxdec} Full featured decoder
\item \hyperlink{example_vpxenc}{vpxenc} Full featured encoder
\item \hyperlink{example_vp8_scalable_patterns}{vp8\+\_\+scalable\+\_\+patterns} Temporal Scalability Encoder
\item \hyperlink{example_vp9_spatial_scalable_encoder}{vp9\+\_\+spatial\+\_\+scalable\+\_\+encoder} Spatial Scalable Encoder 
\end{DoxyItemize}\hypertarget{example_simple_decoder}{}\subsection{simple\+\_\+decoder.\+c}\label{example_simple_decoder}
 \hypertarget{example_postproc}{}\subsection{postproc.\+c}\label{example_postproc}
 \hypertarget{example_decode_to_md5}{}\subsection{decode\+\_\+to\+\_\+md5.\+c}\label{example_decode_to_md5}
 \hypertarget{example_simple_encoder}{}\subsection{simple\+\_\+encoder.\+c}\label{example_simple_encoder}
 \hypertarget{example_twopass_encoder}{}\subsection{twopass\+\_\+encoder.\+c}\label{example_twopass_encoder}
 \hypertarget{example_force_keyframe}{}\subsection{force\+\_\+keyframe.\+c}\label{example_force_keyframe}
 \hypertarget{example_decode_with_drops}{}\subsection{decode\+\_\+with\+\_\+drops.\+c}\label{example_decode_with_drops}
 \hypertarget{example_error_resilient}{}\subsection{error\+\_\+resilient.\+c}\label{example_error_resilient}
 \hypertarget{example_vp8_set_maps}{}\subsection{vp8\+\_\+set\+\_\+maps.\+c}\label{example_vp8_set_maps}
 \hypertarget{example_vp8cx_set_ref}{}\subsection{vp8cx\+\_\+set\+\_\+ref.\+c}\label{example_vp8cx_set_ref}
 \hypertarget{example_vpxdec}{}\subsection{vpxdec}\label{example_vpxdec}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ *  Use of this source code is governed by a BSD-style license}
5 \textcolor{comment}{ *  that can be found in the LICENSE file in the root of the source}
6 \textcolor{comment}{ *  tree. An additional intellectual property rights grant can be found}
7 \textcolor{comment}{ *  in the file PATENTS.  All contributing project authors may}
8 \textcolor{comment}{ *  be found in the AUTHORS file in the root of the source tree.}
9 \textcolor{comment}{ */}
10 
11 
12 \textcolor{comment}{/* This is a simple program that reads ivf files and decodes them}
13 \textcolor{comment}{ * using the new interface. Decoded frames are output as YV12 raw.}
14 \textcolor{comment}{ */}
15 \textcolor{preprocessor}{#include <assert.h>}
16 \textcolor{preprocessor}{#include <stdio.h>}
17 \textcolor{preprocessor}{#include <stdlib.h>}
18 \textcolor{preprocessor}{#include <stdarg.h>}
19 \textcolor{preprocessor}{#include <string.h>}
20 \textcolor{preprocessor}{#include <limits.h>}
21 
22 \textcolor{preprocessor}{#define VPX\_CODEC\_DISABLE\_COMPAT 1}
23 \textcolor{preprocessor}{#include "vpx\_config.h"}
24 \textcolor{preprocessor}{#include "\hyperlink{vpx__decoder_8h}{vpx/vpx\_decoder.h}"}
25 \textcolor{preprocessor}{#include "vpx\_ports/vpx\_timer.h"}
26 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER || CONFIG\_VP9\_DECODER}
27 \textcolor{preprocessor}{#include "\hyperlink{vp8dx_8h}{vpx/vp8dx.h}"}
28 \textcolor{preprocessor}{#endif}
29 \textcolor{preprocessor}{#if CONFIG\_MD5}
30 \textcolor{preprocessor}{#include "md5\_utils.h"}
31 \textcolor{preprocessor}{#endif}
32 \textcolor{preprocessor}{#include "tools\_common.h"}
33 \textcolor{preprocessor}{#include "nestegg/include/nestegg/nestegg.h"}
34 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
35 
36 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
37 
38 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{
39   \textcolor{keywordtype}{char} \textcolor{keyword}{const} *name;
40   \textcolor{keyword}{const} \hyperlink{group__codec_gae99c3b04f4a567a311211cce3ae6b83b}{vpx\_codec\_iface\_t} *(*iface)(void);
41   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}             fourcc;
42   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}             fourcc\_mask;
43 \} ifaces[] = \{
44 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
45   \{\textcolor{stringliteral}{"vp8"},  vpx\_codec\_vp8\_dx,   VP8\_FOURCC\_MASK, 0x00FFFFFF\},
46 \textcolor{preprocessor}{#endif}
47 \textcolor{preprocessor}{#if CONFIG\_VP9\_DECODER}
48   \{\textcolor{stringliteral}{"vp9"},  vpx\_codec\_vp9\_dx,   VP9\_FOURCC\_MASK, 0x00FFFFFF\},
49 \textcolor{preprocessor}{#endif}
50 \};
51 
52 \textcolor{preprocessor}{#include "args.h"}
53 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t looparg = ARG\_DEF(NULL, \textcolor{stringliteral}{"loops"}, 1,
54                                           \textcolor{stringliteral}{"Number of times to decode the file"});
55 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1,
56                                           \textcolor{stringliteral}{"Codec to use"});
57 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 = ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0,
58                                           \textcolor{stringliteral}{"Output raw YV12 frames"});
59 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 = ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0,
60                                           \textcolor{stringliteral}{"Output raw I420 frames"});
61 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t flipuvarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"flipuv"}, 0,
62                                            \textcolor{stringliteral}{"Flip the chroma planes in the output"});
63 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noblitarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"noblit"}, 0,
64                                            \textcolor{stringliteral}{"Don't process the decoded frames"});
65 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t progressarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"progress"}, 0,
66                                              \textcolor{stringliteral}{"Show progress after each frame decodes"});
67 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limitarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1,
68                                           \textcolor{stringliteral}{"Stop decoding after n frames"});
69 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skiparg = ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1,
70                                          \textcolor{stringliteral}{"Skip the first n input frames"});
71 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t postprocarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"postproc"}, 0,
72                                              \textcolor{stringliteral}{"Postprocess decoded frames"});
73 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t summaryarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"summary"}, 0,
74                                             \textcolor{stringliteral}{"Show timing summary"});
75 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile = ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1,
76                                             \textcolor{stringliteral}{"Output file name pattern (see below)"});
77 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threadsarg = ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1,
78                                             \textcolor{stringliteral}{"Max threads to use"});
79 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg = ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0,
80                                             \textcolor{stringliteral}{"Show version string"});
81 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_concealment = ARG\_DEF(NULL, \textcolor{stringliteral}{"error-concealment"}, 0,
82                                                    \textcolor{stringliteral}{"Enable decoder error-concealment"});
83 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scalearg = ARG\_DEF(\textcolor{stringliteral}{"S"}, \textcolor{stringliteral}{"scale"}, 0,
84                                             \textcolor{stringliteral}{"Scale output frames uniformly"});
85 
86 
87 \textcolor{preprocessor}{#if CONFIG\_MD5}
88 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t md5arg = ARG\_DEF(NULL, \textcolor{stringliteral}{"md5"}, 0,
89                                         \textcolor{stringliteral}{"Compute the MD5 sum of the decoded frame"});
90 \textcolor{preprocessor}{#endif}
91 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *all\_args[] = \{
92   &codecarg, &use\_yv12, &use\_i420, &flipuvarg, &noblitarg,
93   &progressarg, &limitarg, &skiparg, &postprocarg, &summaryarg, &outputfile,
94   &threadsarg, &verbosearg, &scalearg,
95 \textcolor{preprocessor}{#if CONFIG\_MD5}
96   &md5arg,
97 \textcolor{preprocessor}{#endif}
98   &error\_concealment,
99   NULL
100 \};
101 
102 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
103 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t addnoise\_level = ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-level"}, 1,
104                                                 \textcolor{stringliteral}{"Enable VP8 postproc add noise"});
105 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deblock = ARG\_DEF(NULL, \textcolor{stringliteral}{"deblock"}, 0,
106                                          \textcolor{stringliteral}{"Enable VP8 deblocking"});
107 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t demacroblock\_level = ARG\_DEF(NULL, \textcolor{stringliteral}{"demacroblock-level"}, 1,
108                                                     \textcolor{stringliteral}{"Enable VP8 demacroblocking, w/ level"});
109 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pp\_debug\_info = ARG\_DEF(NULL, \textcolor{stringliteral}{"pp-debug-info"}, 1,
110                                                \textcolor{stringliteral}{"Enable VP8 visible debug info"});
111 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pp\_disp\_ref\_frame = ARG\_DEF(NULL, \textcolor{stringliteral}{"pp-dbg-ref-frame"}, 1,
112                                                    \textcolor{stringliteral}{"Display only selected reference frame per macro block"})
      ;
113 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pp\_disp\_mb\_modes = ARG\_DEF(NULL, \textcolor{stringliteral}{"pp-dbg-mb-modes"}, 1,
114                                                   \textcolor{stringliteral}{"Display only selected macro block modes"});
115 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pp\_disp\_b\_modes = ARG\_DEF(NULL, \textcolor{stringliteral}{"pp-dbg-b-modes"}, 1,
116                                                  \textcolor{stringliteral}{"Display only selected block modes"});
117 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pp\_disp\_mvs = ARG\_DEF(NULL, \textcolor{stringliteral}{"pp-dbg-mvs"}, 1,
118                                              \textcolor{stringliteral}{"Draw only selected motion vectors"});
119 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mfqe = ARG\_DEF(NULL, \textcolor{stringliteral}{"mfqe"}, 0,
120                                       \textcolor{stringliteral}{"Enable multiframe quality enhancement"});
121 
122 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *vp8\_pp\_args[] = \{
123   &addnoise\_level, &deblock, &demacroblock\_level, &pp\_debug\_info,
124   &pp\_disp\_ref\_frame, &pp\_disp\_mb\_modes, &pp\_disp\_b\_modes, &pp\_disp\_mvs, &mfqe,
125   NULL
126 \};
127 \textcolor{preprocessor}{#endif}
128 
129 \textcolor{keywordtype}{void} usage\_exit() \{
130   \textcolor{keywordtype}{int} i;
131 
132   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <options> filename\(\backslash\)n\(\backslash\)n"}
133           \textcolor{stringliteral}{"Options:\(\backslash\)n"}, exec\_name);
134   arg\_show\_usage(stderr, all\_args);
135 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
136   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nVP8 Postprocessing Options:\(\backslash\)n"});
137   arg\_show\_usage(stderr, vp8\_pp\_args);
138 \textcolor{preprocessor}{#endif}
139   fprintf(stderr,
140           \textcolor{stringliteral}{"\(\backslash\)nOutput File Patterns:\(\backslash\)n\(\backslash\)n"}
141           \textcolor{stringliteral}{"  The -o argument specifies the name of the file(s) to "}
142           \textcolor{stringliteral}{"write to. If the\(\backslash\)n  argument does not include any escape "}
143           \textcolor{stringliteral}{"characters, the output will be\(\backslash\)n  written to a single file. "}
144           \textcolor{stringliteral}{"Otherwise, the filename will be calculated by\(\backslash\)n  expanding "}
145           \textcolor{stringliteral}{"the following escape characters:\(\backslash\)n"});
146   fprintf(stderr,
147           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%w   - Frame width"}
148           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%h   - Frame height"}
149           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%<n> - Frame number, zero padded to <n> places (1..9)"}
150           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n  Pattern arguments are only supported in conjunction "}
151           \textcolor{stringliteral}{"with the --yv12 and\(\backslash\)n  --i420 options. If the -o option is "}
152           \textcolor{stringliteral}{"not specified, the output will be\(\backslash\)n  directed to stdout.\(\backslash\)n"}
153          );
154   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nIncluded decoders:\(\backslash\)n\(\backslash\)n"});
155 
156   \textcolor{keywordflow}{for} (i = 0; i < \textcolor{keyword}{sizeof}(ifaces) / \textcolor{keyword}{sizeof}(ifaces[0]); i++)
157     fprintf(stderr, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"},
158             ifaces[i].name,
159             \hyperlink{group__codec_ga9eee39f450d8cdcf5aba0e2bda6e5aa8}{vpx\_codec\_iface\_name}(ifaces[i].iface()));
160 
161   exit(EXIT\_FAILURE);
162 \}
163 
164 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mem\_get\_le16(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *vmem) \{
165   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}  val;
166   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *mem = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)vmem;
167 
168   val = mem[1] << 8;
169   val |= mem[0];
170   \textcolor{keywordflow}{return} val;
171 \}
172 
173 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mem\_get\_le32(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *vmem) \{
174   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}  val;
175   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *mem = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)vmem;
176 
177   val = mem[3] << 24;
178   val |= mem[2] << 16;
179   val |= mem[1] << 8;
180   val |= mem[0];
181   \textcolor{keywordflow}{return} val;
182 \}
183 
184 \textcolor{keyword}{enum} file\_kind \{
185   RAW\_FILE,
186   IVF\_FILE,
187   WEBM\_FILE
188 \};
189 
190 \textcolor{keyword}{struct }input\_ctx \{
191   \textcolor{keyword}{enum} file\_kind  kind;
192   FILE           *infile;
193   nestegg        *nestegg\_ctx;
194   nestegg\_packet *pkt;
195   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}    chunk;
196   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}    chunks;
197   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}    video\_track;
198 \};
199 
200 \textcolor{preprocessor}{#define IVF\_FRAME\_HDR\_SZ (sizeof(uint32\_t) + sizeof(uint64\_t))}
201 \textcolor{preprocessor}{#define RAW\_FRAME\_HDR\_SZ (sizeof(uint32\_t))}
202 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} input\_ctx      *input,
203                       uint8\_t               **buf,
204                       \textcolor{keywordtype}{size\_t}                *buf\_sz,
205                       \textcolor{keywordtype}{size\_t}                *buf\_alloc\_sz) \{
206   \textcolor{keywordtype}{char}            raw\_hdr[IVF\_FRAME\_HDR\_SZ];
207   \textcolor{keywordtype}{size\_t}          new\_buf\_sz;
208   FILE           *infile = input->infile;
209   \textcolor{keyword}{enum} file\_kind  kind = input->kind;
210   \textcolor{keywordflow}{if} (kind == WEBM\_FILE) \{
211     \textcolor{keywordflow}{if} (input->chunk >= input->chunks) \{
212       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} track;
213 
214       \textcolor{keywordflow}{do} \{
215         \textcolor{comment}{/* End of this packet, get another. */}
216         \textcolor{keywordflow}{if} (input->pkt)
217           nestegg\_free\_packet(input->pkt);
218 
219         \textcolor{keywordflow}{if} (nestegg\_read\_packet(input->nestegg\_ctx, &input->pkt) <= 0
220             || nestegg\_packet\_track(input->pkt, &track))
221           \textcolor{keywordflow}{return} 1;
222 
223       \} \textcolor{keywordflow}{while} (track != input->video\_track);
224 
225       \textcolor{keywordflow}{if} (nestegg\_packet\_count(input->pkt, &input->chunks))
226         \textcolor{keywordflow}{return} 1;
227       input->chunk = 0;
228     \}
229 
230     \textcolor{keywordflow}{if} (nestegg\_packet\_data(input->pkt, input->chunk, buf, buf\_sz))
231       \textcolor{keywordflow}{return} 1;
232     input->chunk++;
233 
234     \textcolor{keywordflow}{return} 0;
235   \}
236   \textcolor{comment}{/* For both the raw and ivf formats, the frame size is the first 4 bytes}
237 \textcolor{comment}{   * of the frame header. We just need to special case on the header}
238 \textcolor{comment}{   * size.}
239 \textcolor{comment}{   */}
240   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fread(raw\_hdr, kind == IVF\_FILE
241                  ? IVF\_FRAME\_HDR\_SZ : RAW\_FRAME\_HDR\_SZ, 1, infile) != 1) \{
242     \textcolor{keywordflow}{if} (!feof(infile))
243       fprintf(stderr, \textcolor{stringliteral}{"Failed to read frame size\(\backslash\)n"});
244 
245     new\_buf\_sz = 0;
246   \} \textcolor{keywordflow}{else} \{
247     new\_buf\_sz = mem\_get\_le32(raw\_hdr);
248 
249     \textcolor{keywordflow}{if} (new\_buf\_sz > 256 * 1024 * 1024) \{
250       fprintf(stderr, \textcolor{stringliteral}{"Error: Read invalid frame size (%u)\(\backslash\)n"},
251               (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})new\_buf\_sz);
252       new\_buf\_sz = 0;
253     \}
254 
255     \textcolor{keywordflow}{if} (kind == RAW\_FILE && new\_buf\_sz > 256 * 1024)
256       fprintf(stderr, \textcolor{stringliteral}{"Warning: Read invalid frame size (%u)"}
257               \textcolor{stringliteral}{" - not a raw file?\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})new\_buf\_sz);
258 
259     \textcolor{keywordflow}{if} (new\_buf\_sz > *buf\_alloc\_sz) \{
260       uint8\_t *new\_buf = realloc(*buf, 2 * new\_buf\_sz);
261 
262       \textcolor{keywordflow}{if} (new\_buf) \{
263         *buf = new\_buf;
264         *buf\_alloc\_sz = 2 * new\_buf\_sz;
265       \} \textcolor{keywordflow}{else} \{
266         fprintf(stderr, \textcolor{stringliteral}{"Failed to allocate compressed data buffer\(\backslash\)n"});
267         new\_buf\_sz = 0;
268       \}
269     \}
270   \}
271 
272   *buf\_sz = new\_buf\_sz;
273 
274   \textcolor{keywordflow}{if} (!feof(infile)) \{
275     \textcolor{keywordflow}{if} (fread(*buf, 1, *buf\_sz, infile) != *buf\_sz) \{
276       fprintf(stderr, \textcolor{stringliteral}{"Failed to read full frame\(\backslash\)n"});
277       \textcolor{keywordflow}{return} 1;
278     \}
279 
280     \textcolor{keywordflow}{return} 0;
281   \}
282 
283   \textcolor{keywordflow}{return} 1;
284 \}
285 
286 \textcolor{keywordtype}{void} *out\_open(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn, \textcolor{keywordtype}{int} do\_md5) \{
287   \textcolor{keywordtype}{void} *out = NULL;
288 
289   \textcolor{keywordflow}{if} (do\_md5) \{
290 \textcolor{preprocessor}{#if CONFIG\_MD5}
291     MD5Context *md5\_ctx = out = malloc(\textcolor{keyword}{sizeof}(MD5Context));
292     (void)out\_fn;
293     MD5Init(md5\_ctx);
294 \textcolor{preprocessor}{#endif}
295   \} \textcolor{keywordflow}{else} \{
296     FILE *outfile = out = strcmp(\textcolor{stringliteral}{"-"}, out\_fn) ? fopen(out\_fn, \textcolor{stringliteral}{"wb"})
297                           : set\_binary\_mode(stdout);
298 
299     \textcolor{keywordflow}{if} (!outfile) \{
300       fprintf(stderr, \textcolor{stringliteral}{"Failed to output file"});
301       exit(EXIT\_FAILURE);
302     \}
303   \}
304 
305   \textcolor{keywordflow}{return} out;
306 \}
307 
308 \textcolor{keywordtype}{void} out\_put(\textcolor{keywordtype}{void} *out, \textcolor{keyword}{const} uint8\_t *buf, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} do\_md5) \{
309   \textcolor{keywordflow}{if} (do\_md5) \{
310 \textcolor{preprocessor}{#if CONFIG\_MD5}
311     MD5Update(out, buf, len);
312 \textcolor{preprocessor}{#endif}
313   \} \textcolor{keywordflow}{else} \{
314     (void) fwrite(buf, 1, len, out);
315   \}
316 \}
317 
318 \textcolor{keywordtype}{void} out\_close(\textcolor{keywordtype}{void} *out, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn, \textcolor{keywordtype}{int} do\_md5) \{
319   \textcolor{keywordflow}{if} (do\_md5) \{
320 \textcolor{preprocessor}{#if CONFIG\_MD5}
321     uint8\_t md5[16];
322     \textcolor{keywordtype}{int} i;
323 
324     MD5Final(md5, out);
325     free(out);
326 
327     \textcolor{keywordflow}{for} (i = 0; i < 16; i++)
328       printf(\textcolor{stringliteral}{"%02x"}, md5[i]);
329 
330     printf(\textcolor{stringliteral}{"  %s\(\backslash\)n"}, out\_fn);
331 \textcolor{preprocessor}{#endif}
332   \} \textcolor{keywordflow}{else} \{
333     fclose(out);
334   \}
335 \}
336 
337 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_is\_ivf(FILE *infile,
338                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fourcc,
339                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *width,
340                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *height,
341                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fps\_den,
342                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fps\_num) \{
343   \textcolor{keywordtype}{char} raw\_hdr[32];
344   \textcolor{keywordtype}{int} is\_ivf = 0;
345 
346   \textcolor{keywordflow}{if} (fread(raw\_hdr, 1, 32, infile) == 32) \{
347     \textcolor{keywordflow}{if} (raw\_hdr[0] == \textcolor{charliteral}{'D'} && raw\_hdr[1] == \textcolor{charliteral}{'K'}
348         && raw\_hdr[2] == \textcolor{charliteral}{'I'} && raw\_hdr[3] == \textcolor{charliteral}{'F'}) \{
349       is\_ivf = 1;
350 
351       \textcolor{keywordflow}{if} (mem\_get\_le16(raw\_hdr + 4) != 0)
352         fprintf(stderr, \textcolor{stringliteral}{"Error: Unrecognized IVF version! This file may not"}
353                 \textcolor{stringliteral}{" decode properly."});
354 
355       *fourcc = mem\_get\_le32(raw\_hdr + 8);
356       *width = mem\_get\_le16(raw\_hdr + 12);
357       *height = mem\_get\_le16(raw\_hdr + 14);
358       *fps\_num = mem\_get\_le32(raw\_hdr + 16);
359       *fps\_den = mem\_get\_le32(raw\_hdr + 20);
360 
361       \textcolor{comment}{/* Some versions of vpxenc used 1/(2*fps) for the timebase, so}
362 \textcolor{comment}{       * we can guess the framerate using only the timebase in this}
363 \textcolor{comment}{       * case. Other files would require reading ahead to guess the}
364 \textcolor{comment}{       * timebase, like we do for webm.}
365 \textcolor{comment}{       */}
366       \textcolor{keywordflow}{if} (*fps\_num < 1000) \{
367         \textcolor{comment}{/* Correct for the factor of 2 applied to the timebase in the}
368 \textcolor{comment}{         * encoder.}
369 \textcolor{comment}{         */}
370         \textcolor{keywordflow}{if} (*fps\_num & 1)*fps\_den <<= 1;
371         \textcolor{keywordflow}{else} *fps\_num >>= 1;
372       \} \textcolor{keywordflow}{else} \{
373         \textcolor{comment}{/* Don't know FPS for sure, and don't have readahead code}
374 \textcolor{comment}{         * (yet?), so just default to 30fps.}
375 \textcolor{comment}{         */}
376         *fps\_num = 30;
377         *fps\_den = 1;
378       \}
379     \}
380   \}
381 
382   \textcolor{keywordflow}{if} (!is\_ivf)
383     rewind(infile);
384 
385   \textcolor{keywordflow}{return} is\_ivf;
386 \}
387 
388 
389 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_is\_raw(FILE *infile,
390                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fourcc,
391                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *width,
392                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *height,
393                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fps\_den,
394                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fps\_num) \{
395   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[32];
396   \textcolor{keywordtype}{int} is\_raw = 0;
397   \hyperlink{structvpx__codec__stream__info}{vpx\_codec\_stream\_info\_t} si;
398 
399   si.\hyperlink{structvpx__codec__stream__info_a8e5eb38a9042da54a20607f71591ddbf}{sz} = \textcolor{keyword}{sizeof}(si);
400 
401   \textcolor{keywordflow}{if} (fread(buf, 1, 32, infile) == 32) \{
402     \textcolor{keywordtype}{int} i;
403 
404     \textcolor{keywordflow}{if} (mem\_get\_le32(buf) < 256 * 1024 * 1024)
405       \textcolor{keywordflow}{for} (i = 0; i < \textcolor{keyword}{sizeof}(ifaces) / \textcolor{keyword}{sizeof}(ifaces[0]); i++)
406         \textcolor{keywordflow}{if} (!\hyperlink{group__decoder_gadfee4664d644175d5aac1465ef11c4b0}{vpx\_codec\_peek\_stream\_info}(ifaces[i].iface(),
407                                         buf + 4, 32 - 4, &si)) \{
408           is\_raw = 1;
409           *fourcc = ifaces[i].fourcc;
410           *width = si.\hyperlink{structvpx__codec__stream__info_a957dbfa83c93d9b3dc08498a6b97c77d}{w};
411           *height = si.\hyperlink{structvpx__codec__stream__info_af7a8b114547e434d182c722bdace63a0}{h};
412           *fps\_num = 30;
413           *fps\_den = 1;
414           \textcolor{keywordflow}{break};
415         \}
416   \}
417 
418   rewind(infile);
419   \textcolor{keywordflow}{return} is\_raw;
420 \}
421 
422 
423 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
424 nestegg\_read\_cb(\textcolor{keywordtype}{void} *buffer, \textcolor{keywordtype}{size\_t} length, \textcolor{keywordtype}{void} *userdata) \{
425   FILE *f = userdata;
426 
427   \textcolor{keywordflow}{if} (fread(buffer, 1, length, f) < length) \{
428     \textcolor{keywordflow}{if} (ferror(f))
429       \textcolor{keywordflow}{return} -1;
430     \textcolor{keywordflow}{if} (feof(f))
431       \textcolor{keywordflow}{return} 0;
432   \}
433   \textcolor{keywordflow}{return} 1;
434 \}
435 
436 
437 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
438 nestegg\_seek\_cb(int64\_t offset, \textcolor{keywordtype}{int} whence, \textcolor{keywordtype}{void} *userdata) \{
439   \textcolor{keywordflow}{switch} (whence) \{
440     \textcolor{keywordflow}{case} NESTEGG\_SEEK\_SET:
441       whence = SEEK\_SET;
442       \textcolor{keywordflow}{break};
443     \textcolor{keywordflow}{case} NESTEGG\_SEEK\_CUR:
444       whence = SEEK\_CUR;
445       \textcolor{keywordflow}{break};
446     \textcolor{keywordflow}{case} NESTEGG\_SEEK\_END:
447       whence = SEEK\_END;
448       \textcolor{keywordflow}{break};
449   \};
450   \textcolor{keywordflow}{return} fseek(userdata, (\textcolor{keywordtype}{long})offset, whence) ? -1 : 0;
451 \}
452 
453 
454 \textcolor{keyword}{static} int64\_t
455 nestegg\_tell\_cb(\textcolor{keywordtype}{void} *userdata) \{
456   \textcolor{keywordflow}{return} ftell(userdata);
457 \}
458 
459 
460 \textcolor{keyword}{static} \textcolor{keywordtype}{void}
461 nestegg\_log\_cb(nestegg *context, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} severity, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *format,
462                ...) \{
463   va\_list ap;
464 
465   va\_start(ap, format);
466   vfprintf(stderr, format, ap);
467   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
468   va\_end(ap);
469 \}
470 
471 
472 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
473 webm\_guess\_framerate(\textcolor{keyword}{struct} input\_ctx *input,
474                      \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *fps\_den,
475                      \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *fps\_num) \{
476   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
477   uint64\_t     tstamp = 0;
478 
479   \textcolor{comment}{/* Check to see if we can seek before we parse any data. */}
480   \textcolor{keywordflow}{if} (nestegg\_track\_seek(input->nestegg\_ctx, input->video\_track, 0)) \{
481     fprintf(stderr,
482             \textcolor{stringliteral}{"WARNING: Failed to guess framerate (no Cues), set to 30fps.\(\backslash\)n"});
483     *fps\_num = 30;
484     *fps\_den = 1;
485     \textcolor{keywordflow}{return} 0;
486   \}
487 
488   \textcolor{comment}{/* Guess the framerate. Read up to 1 second, or 50 video packets,}
489 \textcolor{comment}{   * whichever comes first.}
490 \textcolor{comment}{   */}
491   \textcolor{keywordflow}{for} (i = 0; tstamp < 1000000000 && i < 50;) \{
492     nestegg\_packet *pkt;
493     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} track;
494 
495     \textcolor{keywordflow}{if} (nestegg\_read\_packet(input->nestegg\_ctx, &pkt) <= 0)
496       \textcolor{keywordflow}{break};
497 
498     nestegg\_packet\_track(pkt, &track);
499     \textcolor{keywordflow}{if} (track == input->video\_track) \{
500       nestegg\_packet\_tstamp(pkt, &tstamp);
501       i++;
502     \}
503 
504     nestegg\_free\_packet(pkt);
505   \}
506 
507   \textcolor{keywordflow}{if} (nestegg\_track\_seek(input->nestegg\_ctx, input->video\_track, 0))
508     \textcolor{keywordflow}{goto} fail;
509 
510   *fps\_num = (i - 1) * 1000000;
511   *fps\_den = (\textcolor{keywordtype}{unsigned} int)(tstamp / 1000);
512   \textcolor{keywordflow}{return} 0;
513 fail:
514   nestegg\_destroy(input->nestegg\_ctx);
515   input->nestegg\_ctx = NULL;
516   rewind(input->infile);
517   \textcolor{keywordflow}{return} 1;
518 \}
519 
520 
521 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
522 file\_is\_webm(\textcolor{keyword}{struct} input\_ctx *input,
523              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *fourcc,
524              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *width,
525              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *height,
526              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *fps\_den,
527              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}     *fps\_num) \{
528   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i, n;
529   \textcolor{keywordtype}{int}          track\_type = -1;
530   \textcolor{keywordtype}{int}          codec\_id;
531 
532   nestegg\_io io = \{nestegg\_read\_cb, nestegg\_seek\_cb, nestegg\_tell\_cb, 0\};
533   nestegg\_video\_params params;
534 
535   io.userdata = input->infile;
536   \textcolor{keywordflow}{if} (nestegg\_init(&input->nestegg\_ctx, io, NULL))
537     \textcolor{keywordflow}{goto} fail;
538 
539   \textcolor{keywordflow}{if} (nestegg\_track\_count(input->nestegg\_ctx, &n))
540     \textcolor{keywordflow}{goto} fail;
541 
542   \textcolor{keywordflow}{for} (i = 0; i < n; i++) \{
543     track\_type = nestegg\_track\_type(input->nestegg\_ctx, i);
544 
545     \textcolor{keywordflow}{if} (track\_type == NESTEGG\_TRACK\_VIDEO)
546       \textcolor{keywordflow}{break};
547     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (track\_type < 0)
548       \textcolor{keywordflow}{goto} fail;
549   \}
550 
551   codec\_id = nestegg\_track\_codec\_id(input->nestegg\_ctx, i);
552   \textcolor{keywordflow}{if} (codec\_id == NESTEGG\_CODEC\_VP8) \{
553     *fourcc = VP8\_FOURCC\_MASK;
554   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (codec\_id == NESTEGG\_CODEC\_VP9) \{
555     *fourcc = VP9\_FOURCC\_MASK;
556   \} \textcolor{keywordflow}{else} \{
557     fprintf(stderr, \textcolor{stringliteral}{"Not VPx video, quitting.\(\backslash\)n"});
558     exit(1);
559   \}
560 
561   input->video\_track = i;
562 
563   \textcolor{keywordflow}{if} (nestegg\_track\_video\_params(input->nestegg\_ctx, i, &params))
564     \textcolor{keywordflow}{goto} fail;
565 
566   *fps\_den = 0;
567   *fps\_num = 0;
568   *width = params.width;
569   *height = params.height;
570   \textcolor{keywordflow}{return} 1;
571 fail:
572   input->nestegg\_ctx = NULL;
573   rewind(input->infile);
574   \textcolor{keywordflow}{return} 0;
575 \}
576 
577 
578 \textcolor{keywordtype}{void} show\_progress(\textcolor{keywordtype}{int} frame\_in, \textcolor{keywordtype}{int} frame\_out, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dx\_time) \{
579   fprintf(stderr, \textcolor{stringliteral}{"%d decoded frames/%d showed frames in %lu us (%.2f fps)\(\backslash\)r"},
580           frame\_in, frame\_out, dx\_time,
581           (\textcolor{keywordtype}{float})frame\_out * 1000000.0 / (\textcolor{keywordtype}{float})dx\_time);
582 \}
583 
584 
585 \textcolor{keywordtype}{void} generate\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pattern, \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{size\_t} q\_len,
586                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_h,
587                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in) \{
588   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = pattern;
589   \textcolor{keywordtype}{char} *q = out;
590 
591   \textcolor{keywordflow}{do} \{
592     \textcolor{keywordtype}{char} *next\_pat = strchr(p, \textcolor{charliteral}{'%'});
593 
594     \textcolor{keywordflow}{if} (p == next\_pat) \{
595       \textcolor{keywordtype}{size\_t} pat\_len;
596 
597       \textcolor{comment}{/* parse the pattern */}
598       q[q\_len - 1] = \textcolor{charliteral}{'\(\backslash\)0'};
599       \textcolor{keywordflow}{switch} (p[1]) \{
600         \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}:
601           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_w);
602           \textcolor{keywordflow}{break};
603         \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:
604           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_h);
605           \textcolor{keywordflow}{break};
606         \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:
607           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, frame\_in);
608           \textcolor{keywordflow}{break};
609         \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:
610           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%02d"}, frame\_in);
611           \textcolor{keywordflow}{break};
612         \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:
613           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%03d"}, frame\_in);
614           \textcolor{keywordflow}{break};
615         \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:
616           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%04d"}, frame\_in);
617           \textcolor{keywordflow}{break};
618         \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:
619           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%05d"}, frame\_in);
620           \textcolor{keywordflow}{break};
621         \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:
622           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%06d"}, frame\_in);
623           \textcolor{keywordflow}{break};
624         \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:
625           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%07d"}, frame\_in);
626           \textcolor{keywordflow}{break};
627         \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:
628           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%08d"}, frame\_in);
629           \textcolor{keywordflow}{break};
630         \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:
631           snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%09d"}, frame\_in);
632           \textcolor{keywordflow}{break};
633         \textcolor{keywordflow}{default}:
634           die(\textcolor{stringliteral}{"Unrecognized pattern %%%c\(\backslash\)n"}, p[1]);
635       \}
636 
637       pat\_len = strlen(q);
638       \textcolor{keywordflow}{if} (pat\_len >= q\_len - 1)
639         die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
640       q += pat\_len;
641       p += 2;
642       q\_len -= pat\_len;
643     \} \textcolor{keywordflow}{else} \{
644       \textcolor{keywordtype}{size\_t} copy\_len;
645 
646       \textcolor{comment}{/* copy the next segment */}
647       \textcolor{keywordflow}{if} (!next\_pat)
648         copy\_len = strlen(p);
649       \textcolor{keywordflow}{else}
650         copy\_len = next\_pat - p;
651 
652       \textcolor{keywordflow}{if} (copy\_len >= q\_len - 1)
653         die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
654 
655       memcpy(q, p, copy\_len);
656       q[copy\_len] = \textcolor{charliteral}{'\(\backslash\)0'};
657       q += copy\_len;
658       p += copy\_len;
659       q\_len -= copy\_len;
660     \}
661   \} \textcolor{keywordflow}{while} (*p);
662 \}
663 
664 
665 \textcolor{keywordtype}{int} main\_loop(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
666   \hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t}          decoder;
667   \textcolor{keywordtype}{char}                  *fn = NULL;
668   \textcolor{keywordtype}{int}                    i;
669   uint8\_t               *buf = NULL;
670   \textcolor{keywordtype}{size\_t}                 buf\_sz = 0, buf\_alloc\_sz = 0;
671   FILE                  *infile;
672   \textcolor{keywordtype}{int}                    frame\_in = 0, frame\_out = 0, flipuv = 0, noblit = 0, do\_md5 = 0, progress = 0;
673   \textcolor{keywordtype}{int}                    stop\_after = 0, postproc = 0, summary = 0, quiet = 1;
674   \textcolor{keywordtype}{int}                    arg\_skip = 0;
675   \textcolor{keywordtype}{int}                    ec\_enabled = 0;
676   \hyperlink{group__codec_gae99c3b04f4a567a311211cce3ae6b83b}{vpx\_codec\_iface\_t}       *iface = NULL;
677   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}           fourcc;
678   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}          dx\_time = 0;
679   \textcolor{keyword}{struct }arg               arg;
680   \textcolor{keywordtype}{char}                   **argv, **argi, **argj;
681   \textcolor{keyword}{const} \textcolor{keywordtype}{char}             *outfile\_pattern = 0;
682   \textcolor{keywordtype}{char}                    outfile[PATH\_MAX];
683   \textcolor{keywordtype}{int}                     single\_file;
684   \textcolor{keywordtype}{int}                     use\_y4m = 1;
685   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}            width;
686   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}            height;
687   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}            fps\_den;
688   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}            fps\_num;
689   \textcolor{keywordtype}{void}                   *out = NULL;
690   \hyperlink{structvpx__codec__dec__cfg}{vpx\_codec\_dec\_cfg\_t}     cfg = \{0\};
691 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
692   \hyperlink{structvp8__postproc__cfg}{vp8\_postproc\_cfg\_t}      vp8\_pp\_cfg = \{0\};
693   \textcolor{keywordtype}{int}                     vp8\_dbg\_color\_ref\_frame = 0;
694   \textcolor{keywordtype}{int}                     vp8\_dbg\_color\_mb\_modes = 0;
695   \textcolor{keywordtype}{int}                     vp8\_dbg\_color\_b\_modes = 0;
696   \textcolor{keywordtype}{int}                     vp8\_dbg\_display\_mv = 0;
697 \textcolor{preprocessor}{#endif}
698   \textcolor{keyword}{struct }input\_ctx        input = \{0\};
699   \textcolor{keywordtype}{int}                     frames\_corrupted = 0;
700   \textcolor{keywordtype}{int}                     dec\_flags = 0;
701   \textcolor{keywordtype}{int}                     do\_scale = 0;
702   \textcolor{keywordtype}{int}                     stream\_w = 0, stream\_h = 0;
703   \hyperlink{structvpx__image}{vpx\_image\_t}             *scaled\_img = NULL;
704   \textcolor{keywordtype}{int}                     frame\_avail, got\_data;
705 
706   \textcolor{comment}{/* Parse command line */}
707   exec\_name = argv\_[0];
708   argv = argv\_dup(argc - 1, argv\_ + 1);
709 
710   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
711     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
712     arg.argv\_step = 1;
713 
714     \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
715       \textcolor{keywordtype}{int} j, k = -1;
716 
717       \textcolor{keywordflow}{for} (j = 0; j < \textcolor{keyword}{sizeof}(ifaces) / \textcolor{keyword}{sizeof}(ifaces[0]); j++)
718         \textcolor{keywordflow}{if} (!strcmp(ifaces[j].name, arg.val))
719           k = j;
720 
721       \textcolor{keywordflow}{if} (k >= 0)
722         iface = ifaces[k].iface();
723       \textcolor{keywordflow}{else}
724         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"},
725             arg.val);
726     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
727       \textcolor{comment}{// no-op}
728     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi))
729       outfile\_pattern = arg.val;
730     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi)) \{
731       use\_y4m = 0;
732       flipuv = 1;
733     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi)) \{
734       use\_y4m = 0;
735       flipuv = 0;
736     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &flipuvarg, argi))
737       flipuv = 1;
738     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &noblitarg, argi))
739       noblit = 1;
740     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &progressarg, argi))
741       progress = 1;
742     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limitarg, argi))
743       stop\_after = arg\_parse\_uint(&arg);
744     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skiparg, argi))
745       arg\_skip = arg\_parse\_uint(&arg);
746     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &postprocarg, argi))
747       postproc = 1;
748     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &md5arg, argi))
749       do\_md5 = 1;
750     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &summaryarg, argi))
751       summary = 1;
752     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threadsarg, argi))
753       cfg.\hyperlink{structvpx__codec__dec__cfg_afca69d81e99ee15e1d641a639aefb7eb}{threads} = arg\_parse\_uint(&arg);
754     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
755       quiet = 0;
756     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scalearg, argi))
757       do\_scale = 1;
758 
759 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
760     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &addnoise\_level, argi)) \{
761       postproc = 1;
762       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} |= VP8\_ADDNOISE;
763       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_a32f28e4003e5d9bf55d188247f3f156c}{noise\_level} = arg\_parse\_uint(&arg);
764     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &demacroblock\_level, argi)) \{
765       postproc = 1;
766       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} |= VP8\_DEMACROBLOCK;
767       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_afe919a9546e79798d840b1492f7e0249}{deblocking\_level} = arg\_parse\_uint(&arg);
768     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &deblock, argi)) \{
769       postproc = 1;
770       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} |= VP8\_DEBLOCK;
771     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &mfqe, argi)) \{
772       postproc = 1;
773       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} |= VP8\_MFQE;
774     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pp\_debug\_info, argi)) \{
775       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} level = arg\_parse\_uint(&arg);
776 
777       postproc = 1;
778       vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} &= ~0x7;
779 
780       \textcolor{keywordflow}{if} (level)
781         vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag} |= level;
782     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pp\_disp\_ref\_frame, argi)) \{
783       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flags = arg\_parse\_int(&arg);
784       \textcolor{keywordflow}{if} (flags) \{
785         postproc = 1;
786         vp8\_dbg\_color\_ref\_frame = flags;
787       \}
788     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pp\_disp\_mb\_modes, argi)) \{
789       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flags = arg\_parse\_int(&arg);
790       \textcolor{keywordflow}{if} (flags) \{
791         postproc = 1;
792         vp8\_dbg\_color\_mb\_modes = flags;
793       \}
794     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pp\_disp\_b\_modes, argi)) \{
795       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flags = arg\_parse\_int(&arg);
796       \textcolor{keywordflow}{if} (flags) \{
797         postproc = 1;
798         vp8\_dbg\_color\_b\_modes = flags;
799       \}
800     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pp\_disp\_mvs, argi)) \{
801       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flags = arg\_parse\_int(&arg);
802       \textcolor{keywordflow}{if} (flags) \{
803         postproc = 1;
804         vp8\_dbg\_display\_mv = flags;
805       \}
806     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &error\_concealment, argi)) \{
807       ec\_enabled = 1;
808     \}
809 
810 \textcolor{preprocessor}{#endif}
811     \textcolor{keywordflow}{else}
812       argj++;
813   \}
814 
815   \textcolor{comment}{/* Check for unrecognized options */}
816   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
817     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
818       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
819 
820   \textcolor{comment}{/* Handle non-option arguments */}
821   fn = argv[0];
822 
823   \textcolor{keywordflow}{if} (!fn)
824     usage\_exit();
825 
826   \textcolor{comment}{/* Open file */}
827   infile = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"rb"}) : set\_binary\_mode(stdin);
828 
829   \textcolor{keywordflow}{if} (!infile) \{
830     fprintf(stderr, \textcolor{stringliteral}{"Failed to open file '%s'"},
831             strcmp(fn, \textcolor{stringliteral}{"-"}) ? fn : \textcolor{stringliteral}{"stdin"});
832     \textcolor{keywordflow}{return} EXIT\_FAILURE;
833   \}
834 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
835   \textcolor{comment}{/* Make sure we don't dump to the terminal, unless forced to with -o - */}
836   \textcolor{keywordflow}{if} (!outfile\_pattern && isatty(fileno(stdout)) && !do\_md5 && !noblit) \{
837     fprintf(stderr,
838             \textcolor{stringliteral}{"Not dumping raw video to your terminal. Use '-o -' to "}
839             \textcolor{stringliteral}{"override.\(\backslash\)n"});
840     \textcolor{keywordflow}{return} EXIT\_FAILURE;
841   \}
842 \textcolor{preprocessor}{#endif}
843   input.infile = infile;
844   \textcolor{keywordflow}{if} (file\_is\_ivf(infile, &fourcc, &width, &height, &fps\_den,
845                   &fps\_num))
846     input.kind = IVF\_FILE;
847   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_webm(&input, &fourcc, &width, &height, &fps\_den, &fps\_num))
848     input.kind = WEBM\_FILE;
849   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_raw(infile, &fourcc, &width, &height, &fps\_den, &fps\_num))
850     input.kind = RAW\_FILE;
851   \textcolor{keywordflow}{else} \{
852     fprintf(stderr, \textcolor{stringliteral}{"Unrecognized input file type.\(\backslash\)n"});
853     \textcolor{keywordflow}{return} EXIT\_FAILURE;
854   \}
855 
856   \textcolor{comment}{/* If the output file is not set or doesn't have a sequence number in}
857 \textcolor{comment}{   * it, then we only open it once.}
858 \textcolor{comment}{   */}
859   outfile\_pattern = outfile\_pattern ? outfile\_pattern : \textcolor{stringliteral}{"-"};
860   single\_file = 1;
861   \{
862     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = outfile\_pattern;
863     \textcolor{keywordflow}{do} \{
864       p = strchr(p, \textcolor{charliteral}{'%'});
865       \textcolor{keywordflow}{if} (p && p[1] >= \textcolor{charliteral}{'1'} && p[1] <= \textcolor{charliteral}{'9'}) \{
866         \textcolor{comment}{/* pattern contains sequence number, so it's not unique. */}
867         single\_file = 0;
868         \textcolor{keywordflow}{break};
869       \}
870       \textcolor{keywordflow}{if} (p)
871         p++;
872     \} \textcolor{keywordflow}{while} (p);
873   \}
874 
875   \textcolor{keywordflow}{if} (single\_file && !noblit) \{
876     generate\_filename(outfile\_pattern, outfile, \textcolor{keyword}{sizeof}(outfile) - 1,
877                       width, height, 0);
878     out = out\_open(outfile, do\_md5);
879   \}
880 
881   \textcolor{keywordflow}{if} (use\_y4m && !noblit) \{
882     \textcolor{keywordtype}{char} buffer[128];
883 
884     \textcolor{keywordflow}{if} (!single\_file) \{
885       fprintf(stderr, \textcolor{stringliteral}{"YUV4MPEG2 not supported with output patterns,"}
886               \textcolor{stringliteral}{" try --i420 or --yv12.\(\backslash\)n"});
887       \textcolor{keywordflow}{return} EXIT\_FAILURE;
888     \}
889 
890     \textcolor{keywordflow}{if} (input.kind == WEBM\_FILE)
891       \textcolor{keywordflow}{if} (webm\_guess\_framerate(&input, &fps\_den, &fps\_num)) \{
892         fprintf(stderr, \textcolor{stringliteral}{"Failed to guess framerate -- error parsing "}
893                 \textcolor{stringliteral}{"webm file?\(\backslash\)n"});
894         \textcolor{keywordflow}{return} EXIT\_FAILURE;
895       \}
896 
897 
898     \textcolor{comment}{/*Note: We can't output an aspect ratio here because IVF doesn't}
899 \textcolor{comment}{       store one, and neither does VP8.}
900 \textcolor{comment}{      That will have to wait until these tools support WebM natively.*/}
901     snprintf(buffer, \textcolor{keyword}{sizeof}(buffer), \textcolor{stringliteral}{"YUV4MPEG2 W%u H%u F%u:%u I%c "},
902              width, height, fps\_num, fps\_den, \textcolor{charliteral}{'p'});
903     out\_put(out, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)buffer,
904             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})strlen(buffer), do\_md5);
905   \}
906 
907   \textcolor{comment}{/* Try to determine the codec from the fourcc. */}
908   \textcolor{keywordflow}{for} (i = 0; i < \textcolor{keyword}{sizeof}(ifaces) / \textcolor{keyword}{sizeof}(ifaces[0]); i++)
909     \textcolor{keywordflow}{if} ((fourcc & ifaces[i].fourcc\_mask) == ifaces[i].fourcc) \{
910       \hyperlink{group__codec_gae99c3b04f4a567a311211cce3ae6b83b}{vpx\_codec\_iface\_t}  *ivf\_iface = ifaces[i].iface();
911 
912       \textcolor{keywordflow}{if} (iface && iface != ivf\_iface)
913         fprintf(stderr, \textcolor{stringliteral}{"Notice -- IVF header indicates codec: %s\(\backslash\)n"},
914                 ifaces[i].name);
915       \textcolor{keywordflow}{else}
916         iface = ivf\_iface;
917 
918       \textcolor{keywordflow}{break};
919     \}
920 
921   dec\_flags = (postproc ? \hyperlink{group__decoder_ga6fe14f30254aff769412b128b29664cc}{VPX\_CODEC\_USE\_POSTPROC} : 0) |
922               (ec\_enabled ? \hyperlink{group__decoder_ga520d7005e360202f5844982fa2392581}{VPX\_CODEC\_USE\_ERROR\_CONCEALMENT} : 0);
923   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_ga8c2f0b12f1bd4927eb3c68b01eab19d3}{vpx\_codec\_dec\_init}(&decoder, iface ? iface :  ifaces[0].iface(), &cfg,
924                          dec\_flags)) \{
925     fprintf(stderr, \textcolor{stringliteral}{"Failed to initialize decoder: %s\(\backslash\)n"}, \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
926     \textcolor{keywordflow}{return} EXIT\_FAILURE;
927   \}
928 
929   \textcolor{keywordflow}{if} (!quiet)
930     fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, decoder.\hyperlink{structvpx__codec__ctx_a7ed1bf8f6434ea2df01da8011849c6cb}{name});
931 
932 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER}
933 
934   \textcolor{keywordflow}{if} (vp8\_pp\_cfg.\hyperlink{structvp8__postproc__cfg_ae9adc230642ac230f39eb4c531cf85e5}{post\_proc\_flag}
935       && \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599a43e85c68bc1c1473f4a94b005a59482c}{VP8\_SET\_POSTPROC}, &vp8\_pp\_cfg)) \{
936     fprintf(stderr, \textcolor{stringliteral}{"Failed to configure postproc: %s\(\backslash\)n"}, \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
937     \textcolor{keywordflow}{return} EXIT\_FAILURE;
938   \}
939 
940   \textcolor{keywordflow}{if} (vp8\_dbg\_color\_ref\_frame
941       && \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, 
      \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599ab52ea7a97668b603812dfc205b0fd783}{VP8\_SET\_DBG\_COLOR\_REF\_FRAME}, vp8\_dbg\_color\_ref\_frame)) \{
942     fprintf(stderr, \textcolor{stringliteral}{"Failed to configure reference block visualizer: %s\(\backslash\)n"}, 
      \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
943     \textcolor{keywordflow}{return} EXIT\_FAILURE;
944   \}
945 
946   \textcolor{keywordflow}{if} (vp8\_dbg\_color\_mb\_modes
947       && \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599aa0d5c3eaa7cbecaf64403edc8450b060}{VP8\_SET\_DBG\_COLOR\_MB\_MODES},
       vp8\_dbg\_color\_mb\_modes)) \{
948     fprintf(stderr, \textcolor{stringliteral}{"Failed to configure macro block visualizer: %s\(\backslash\)n"}, 
      \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
949     \textcolor{keywordflow}{return} EXIT\_FAILURE;
950   \}
951 
952   \textcolor{keywordflow}{if} (vp8\_dbg\_color\_b\_modes
953       && \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599ae0052b9dd3c64a4bb822abafb4755a87}{VP8\_SET\_DBG\_COLOR\_B\_MODES}, 
      vp8\_dbg\_color\_b\_modes)) \{
954     fprintf(stderr, \textcolor{stringliteral}{"Failed to configure block visualizer: %s\(\backslash\)n"}, 
      \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
955     \textcolor{keywordflow}{return} EXIT\_FAILURE;
956   \}
957 
958   \textcolor{keywordflow}{if} (vp8\_dbg\_display\_mv
959       && \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599abc6aef0d7e0486d25348de217ad8441d}{VP8\_SET\_DBG\_DISPLAY\_MV}, 
      vp8\_dbg\_display\_mv)) \{
960     fprintf(stderr, \textcolor{stringliteral}{"Failed to configure motion vector visualizer: %s\(\backslash\)n"}, 
      \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
961     \textcolor{keywordflow}{return} EXIT\_FAILURE;
962   \}
963 \textcolor{preprocessor}{#endif}
964 
965 
966   \textcolor{keywordflow}{if}(arg\_skip)
967     fprintf(stderr, \textcolor{stringliteral}{"Skiping first %d frames.\(\backslash\)n"}, arg\_skip);
968   \textcolor{keywordflow}{while} (arg\_skip) \{
969     \textcolor{keywordflow}{if} (read\_frame(&input, &buf, &buf\_sz, &buf\_alloc\_sz))
970       \textcolor{keywordflow}{break};
971     arg\_skip--;
972   \}
973 
974   frame\_avail = 1;
975   got\_data = 0;
976 
977   \textcolor{comment}{/* Decode file */}
978   \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
979     \hyperlink{group__codec_ga6ea348f76b1f8a1fe50e14db684146c6}{vpx\_codec\_iter\_t}  iter = NULL;
980     \hyperlink{structvpx__image}{vpx\_image\_t}    *img;
981     \textcolor{keyword}{struct }vpx\_usec\_timer timer;
982     \textcolor{keywordtype}{int}                   corrupted;
983 
984     frame\_avail = 0;
985     \textcolor{keywordflow}{if} (!stop\_after || frame\_in < stop\_after) \{
986       \textcolor{keywordflow}{if}(!read\_frame(&input, &buf, &buf\_sz, &buf\_alloc\_sz)) \{
987         frame\_avail = 1;
988         frame\_in++;
989 
990         vpx\_usec\_timer\_start(&timer);
991 
992         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_ga3441e157a7a69108bca9a069f2ee8e0d}{vpx\_codec\_decode}(&decoder, buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})buf\_sz, NULL, 0)) \{
993           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga29273cb552ed1a437fe263c4a0a54300}{vpx\_codec\_error\_detail}(&decoder);
994           fprintf(stderr, \textcolor{stringliteral}{"Failed to decode frame: %s\(\backslash\)n"},
995                   \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
996 
997           \textcolor{keywordflow}{if} (detail)
998             fprintf(stderr, \textcolor{stringliteral}{"  Additional information: %s\(\backslash\)n"}, detail);
999           \textcolor{keywordflow}{goto} fail;
1000         \}
1001 
1002         vpx\_usec\_timer\_mark(&timer);
1003         dx\_time += (\textcolor{keywordtype}{unsigned} int)vpx\_usec\_timer\_elapsed(&timer);
1004       \}
1005     \}
1006 
1007     vpx\_usec\_timer\_start(&timer);
1008 
1009     got\_data = 0;
1010     \textcolor{keywordflow}{if} ((img = \hyperlink{group__decoder_ga0e231c3a5ce445fdb2268d741da97500}{vpx\_codec\_get\_frame}(&decoder, &iter))) \{
1011       ++frame\_out;
1012       got\_data = 1;
1013     \}
1014 
1015     vpx\_usec\_timer\_mark(&timer);
1016     dx\_time += (\textcolor{keywordtype}{unsigned} int)vpx\_usec\_timer\_elapsed(&timer);
1017 
1018     \textcolor{keywordflow}{if} (\hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&decoder, \hyperlink{group__vp8__decoder_ggaf9dd3f2e6d1412106ee791af768e57c1af9f82d9e7930e6a2244b30b031b79599}{VP8D\_GET\_FRAME\_CORRUPTED}, &
      corrupted)) \{
1019       fprintf(stderr, \textcolor{stringliteral}{"Failed VP8\_GET\_FRAME\_CORRUPTED: %s\(\backslash\)n"},
1020               \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
1021       \textcolor{keywordflow}{goto} fail;
1022     \}
1023     frames\_corrupted += corrupted;
1024 
1025     \textcolor{keywordflow}{if} (progress)
1026       show\_progress(frame\_in, frame\_out, dx\_time);
1027 
1028     \textcolor{keywordflow}{if} (!noblit) \{
1029       \textcolor{keywordflow}{if} (frame\_out == 1 && img && use\_y4m) \{
1030         \textcolor{comment}{/* Write out the color format to terminate the header line */}
1031         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *color =
1032             img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193a945b48eb8ded59cfa6e544b5888da76c}{VPX\_IMG\_FMT\_444A} ? \textcolor{stringliteral}{"C444alpha\(\backslash\)n"} :
1033             img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193aaeaaafc8f14c88e1a63ff9da398c9f99}{VPX\_IMG\_FMT\_I444} ? \textcolor{stringliteral}{"C444\(\backslash\)n"} :
1034             img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193aff252f61fc80e0c71924beac4615e812}{VPX\_IMG\_FMT\_I422} ? \textcolor{stringliteral}{"C422\(\backslash\)n"} :
1035             \textcolor{stringliteral}{"C420jpeg\(\backslash\)n"};
1036 
1037         out\_put(out, (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)color, strlen(color), do\_md5);
1038       \}
1039 
1040       \textcolor{keywordflow}{if} (do\_scale) \{
1041         \textcolor{keywordflow}{if} (img && frame\_out == 1) \{
1042           stream\_w = img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w};
1043           stream\_h = img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h};
1044           scaled\_img = \hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(NULL, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420},
1045                                      stream\_w, stream\_h, 16);
1046         \}
1047         \textcolor{keywordflow}{if} (img && (img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w} != stream\_w || img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h} != stream\_h)) \{
1048           assert(img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420});
1049           I420Scale(img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}],
1050                     img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}],
1051                     img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1052                     img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}, img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h},
1053                     scaled\_img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}],
1054                     scaled\_img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}],
1055                     scaled\_img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}],
1056                     scaled\_img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}],
1057                     scaled\_img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1058                     scaled\_img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1059                     stream\_w, stream\_h,
1060                     kFilterBox);
1061           img = scaled\_img;
1062         \}
1063       \}
1064 
1065       \textcolor{keywordflow}{if} (img) \{
1066         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} y;
1067         \textcolor{keywordtype}{char} out\_fn[PATH\_MAX];
1068         uint8\_t *buf;
1069         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} c\_w =
1070             img->\hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift} ? (1 + img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}) >> img->
      \hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift}
1071                                 : img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w};
1072         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} c\_h =
1073             img->\hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift} ? (1 + img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}) >> img->
      \hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift}
1074                                 : img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h};
1075 
1076         \textcolor{keywordflow}{if} (!single\_file) \{
1077           \textcolor{keywordtype}{size\_t} len = \textcolor{keyword}{sizeof}(out\_fn) - 1;
1078 
1079           out\_fn[len] = \textcolor{charliteral}{'\(\backslash\)0'};
1080           generate\_filename(outfile\_pattern, out\_fn, len - 1,
1081                             img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}, img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}, frame\_in);
1082           out = out\_open(out\_fn, do\_md5);
1083         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_y4m)
1084           out\_put(out, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"FRAME\(\backslash\)n"}, 6, do\_md5);
1085 
1086         buf = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}];
1087 
1088         \textcolor{keywordflow}{for} (y = 0; y < img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}; y++) \{
1089           out\_put(out, buf, img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}, do\_md5);
1090           buf += img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}];
1091         \}
1092 
1093         buf = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[flipuv ? \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V} : \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}];
1094 
1095         \textcolor{keywordflow}{for} (y = 0; y < c\_h; y++) \{
1096           out\_put(out, buf, c\_w, do\_md5);
1097           buf += img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}];
1098         \}
1099 
1100         buf = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[flipuv ? \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U} : \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}];
1101 
1102         \textcolor{keywordflow}{for} (y = 0; y < c\_h; y++) \{
1103           out\_put(out, buf, c\_w, do\_md5);
1104           buf += img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}];
1105         \}
1106 
1107         \textcolor{keywordflow}{if} (!single\_file)
1108           out\_close(out, out\_fn, do\_md5);
1109       \}
1110     \}
1111 
1112     \textcolor{keywordflow}{if} (stop\_after && frame\_in >= stop\_after)
1113       \textcolor{keywordflow}{break};
1114   \}
1115 
1116   \textcolor{keywordflow}{if} (summary || progress) \{
1117     show\_progress(frame\_in, frame\_out, dx\_time);
1118     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
1119   \}
1120 
1121   \textcolor{keywordflow}{if} (frames\_corrupted)
1122     fprintf(stderr, \textcolor{stringliteral}{"WARNING: %d frames corrupted.\(\backslash\)n"}, frames\_corrupted);
1123 
1124 fail:
1125 
1126   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6ae21d96909660d0ac978b59a863f53b}{vpx\_codec\_destroy}(&decoder)) \{
1127     fprintf(stderr, \textcolor{stringliteral}{"Failed to destroy decoder: %s\(\backslash\)n"},
1128             \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(&decoder));
1129     \textcolor{keywordflow}{return} EXIT\_FAILURE;
1130   \}
1131 
1132   \textcolor{keywordflow}{if} (single\_file && !noblit)
1133     out\_close(out, outfile, do\_md5);
1134 
1135   \textcolor{keywordflow}{if} (input.nestegg\_ctx)
1136     nestegg\_destroy(input.nestegg\_ctx);
1137   \textcolor{keywordflow}{if} (input.kind != WEBM\_FILE)
1138     free(buf);
1139 
1140   \textcolor{keywordflow}{if} (scaled\_img) \hyperlink{vpx__image_8h_af47ebaf286812d037425d41990d48a17}{vpx\_img\_free}(scaled\_img);
1141 
1142   fclose(infile);
1143   free(argv);
1144 
1145   \textcolor{keywordflow}{return} frames\_corrupted ? EXIT\_FAILURE : EXIT\_SUCCESS;
1146 \}
1147 
1148 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1149   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loops = 1, i;
1150   \textcolor{keywordtype}{char} **argv, **argi, **argj;
1151   \textcolor{keyword}{struct }arg arg;
1152   \textcolor{keywordtype}{int} error = 0;
1153 
1154   argv = argv\_dup(argc - 1, argv\_ + 1);
1155   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1156     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
1157     arg.argv\_step = 1;
1158 
1159     \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
1160       loops = arg\_parse\_uint(&arg);
1161       \textcolor{keywordflow}{break};
1162     \}
1163   \}
1164   free(argv);
1165   \textcolor{keywordflow}{for} (i = 0; !error && i < loops; i++)
1166     error = main\_loop(argc, argv\_);
1167   \textcolor{keywordflow}{return} error;
1168 \}
\end{DoxyCodeInclude}
 \hypertarget{example_vpxenc}{}\subsection{vpxenc}\label{example_vpxenc}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ *  Use of this source code is governed by a BSD-style license}
5 \textcolor{comment}{ *  that can be found in the LICENSE file in the root of the source}
6 \textcolor{comment}{ *  tree. An additional intellectual property rights grant can be found}
7 \textcolor{comment}{ *  in the file PATENTS.  All contributing project authors may}
8 \textcolor{comment}{ *  be found in the AUTHORS file in the root of the source tree.}
9 \textcolor{comment}{ */}
10 
11 \textcolor{preprocessor}{#include "./vpx\_config.h"}
12 
13 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(\_\_OS2\_\_) || !CONFIG\_OS\_SUPPORT}
14 \textcolor{preprocessor}{#define USE\_POSIX\_MMAP 0}
15 \textcolor{preprocessor}{#else}
16 \textcolor{preprocessor}{#define USE\_POSIX\_MMAP 1}
17 \textcolor{preprocessor}{#endif}
18 
19 \textcolor{preprocessor}{#include <math.h>}
20 \textcolor{preprocessor}{#include <stdio.h>}
21 \textcolor{preprocessor}{#include <stdlib.h>}
22 \textcolor{preprocessor}{#include <stdarg.h>}
23 \textcolor{preprocessor}{#include <string.h>}
24 \textcolor{preprocessor}{#include <limits.h>}
25 \textcolor{preprocessor}{#include <assert.h>}
26 \textcolor{preprocessor}{#include "\hyperlink{vpx__encoder_8h}{vpx/vpx\_encoder.h}"}
27 \textcolor{preprocessor}{#if CONFIG\_DECODERS}
28 \textcolor{preprocessor}{#include "\hyperlink{vpx__decoder_8h}{vpx/vpx\_decoder.h}"}
29 \textcolor{preprocessor}{#endif}
30 \textcolor{preprocessor}{#if USE\_POSIX\_MMAP}
31 \textcolor{preprocessor}{#include <sys/types.h>}
32 \textcolor{preprocessor}{#include <sys/stat.h>}
33 \textcolor{preprocessor}{#include <sys/mman.h>}
34 \textcolor{preprocessor}{#include <fcntl.h>}
35 \textcolor{preprocessor}{#include <unistd.h>}
36 \textcolor{preprocessor}{#endif}
37 
38 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
39 
40 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER || CONFIG\_VP9\_ENCODER}
41 \textcolor{preprocessor}{#include "\hyperlink{vp8cx_8h}{vpx/vp8cx.h}"}
42 \textcolor{preprocessor}{#endif}
43 \textcolor{preprocessor}{#if CONFIG\_VP8\_DECODER || CONFIG\_VP9\_DECODER}
44 \textcolor{preprocessor}{#include "\hyperlink{vp8dx_8h}{vpx/vp8dx.h}"}
45 \textcolor{preprocessor}{#endif}
46 
47 \textcolor{preprocessor}{#include "./tools\_common.h"}
48 \textcolor{preprocessor}{#include "vpx\_ports/mem\_ops.h"}
49 \textcolor{preprocessor}{#include "vpx\_ports/vpx\_timer.h"}
50 \textcolor{preprocessor}{#include "./vpxstats.h"}
51 \textcolor{preprocessor}{#include "./webmenc.h"}
52 \textcolor{preprocessor}{#include "./y4minput.h"}
53 
54 \textcolor{comment}{/* Swallow warnings about unused results of fread/fwrite */}
55 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fread(\textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
56                          FILE *stream) \{
57   \textcolor{keywordflow}{return} fread(ptr, size, nmemb, stream);
58 \}
59 \textcolor{preprocessor}{#define fread wrap\_fread}
60 
61 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
62                           FILE *stream) \{
63   \textcolor{keywordflow}{return} fwrite(ptr, size, nmemb, stream);
64 \}
65 \textcolor{preprocessor}{#define fwrite wrap\_fwrite}
66 
67 
68 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
69 
70 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }codec\_item \{
71   \textcolor{keywordtype}{char} \textcolor{keyword}{const}              *name;
72   \textcolor{keyword}{const} \hyperlink{group__codec_gae99c3b04f4a567a311211cce3ae6b83b}{vpx\_codec\_iface\_t} *(*iface)(void);
73   \textcolor{keyword}{const} \hyperlink{group__codec_gae99c3b04f4a567a311211cce3ae6b83b}{vpx\_codec\_iface\_t} *(*dx\_iface)(void);
74   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}             fourcc;
75 \} codecs[] = \{
76 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER && CONFIG\_VP8\_DECODER}
77   \{\textcolor{stringliteral}{"vp8"}, &vpx\_codec\_vp8\_cx, &vpx\_codec\_vp8\_dx, VP8\_FOURCC\},
78 \textcolor{preprocessor}{#elif CONFIG\_VP8\_ENCODER && !CONFIG\_VP8\_DECODER}
79   \{\textcolor{stringliteral}{"vp8"}, &vpx\_codec\_vp8\_cx, NULL, VP8\_FOURCC\},
80 \textcolor{preprocessor}{#endif}
81 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER && CONFIG\_VP9\_DECODER}
82   \{\textcolor{stringliteral}{"vp9"}, &vpx\_codec\_vp9\_cx, &vpx\_codec\_vp9\_dx, VP9\_FOURCC\},
83 \textcolor{preprocessor}{#elif CONFIG\_VP9\_ENCODER && !CONFIG\_VP9\_DECODER}
84   \{\textcolor{stringliteral}{"vp9"}, &vpx\_codec\_vp9\_cx, NULL, VP9\_FOURCC\},
85 \textcolor{preprocessor}{#endif}
86 \};
87 
88 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_errorv(\hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
89                                    \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, va\_list ap) \{
90   \textcolor{keywordflow}{if} (ctx->\hyperlink{structvpx__codec__ctx_a6f448802b0675013fd8c5179675c30de}{err}) \{
91     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga29273cb552ed1a437fe263c4a0a54300}{vpx\_codec\_error\_detail}(ctx);
92 
93     vfprintf(stderr, s, ap);
94     fprintf(stderr, \textcolor{stringliteral}{": %s\(\backslash\)n"}, \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(ctx));
95 
96     \textcolor{keywordflow}{if} (detail)
97       fprintf(stderr, \textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
98 
99     \textcolor{keywordflow}{if} (fatal)
100       exit(EXIT\_FAILURE);
101   \}
102 \}
103 
104 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ctx\_exit\_on\_error(\hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
105   va\_list ap;
106 
107   va\_start(ap, s);
108   warn\_or\_exit\_on\_errorv(ctx, 1, s, ap);
109   va\_end(ap);
110 \}
111 
112 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_error(\hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
113                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
114   va\_list ap;
115 
116   va\_start(ap, s);
117   warn\_or\_exit\_on\_errorv(ctx, fatal, s, ap);
118   va\_end(ap);
119 \}
120 
121 \textcolor{keyword}{enum} video\_file\_type \{
122   FILE\_TYPE\_RAW,
123   FILE\_TYPE\_IVF,
124   FILE\_TYPE\_Y4M
125 \};
126 
127 \textcolor{keyword}{struct }detect\_buffer \{
128   \textcolor{keywordtype}{char} buf[4];
129   \textcolor{keywordtype}{size\_t} buf\_read;
130   \textcolor{keywordtype}{size\_t} position;
131 \};
132 
133 
134 \textcolor{keyword}{struct }input\_state \{
135   \textcolor{keywordtype}{char}                 *fn;
136   FILE                 *file;
137   off\_t                 length;
138   y4m\_input             y4m;
139   \textcolor{keyword}{struct }detect\_buffer  detect;
140   \textcolor{keyword}{enum} video\_file\_type  file\_type;
141   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}          w;
142   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}          h;
143   \textcolor{keyword}{struct }\hyperlink{structvpx__rational}{vpx\_rational}   framerate;
144   \textcolor{keywordtype}{int}                   use\_i420;
145   \textcolor{keywordtype}{int}                   only\_i420;
146 \};
147 
148 \textcolor{preprocessor}{#define IVF\_FRAME\_HDR\_SZ (4+8) }\textcolor{comment}{/* 4 byte size + 8 byte timestamp */}\textcolor{preprocessor}{}
149 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} input\_state *input, \hyperlink{structvpx__image}{vpx\_image\_t} *img) \{
150   FILE *f = input->file;
151   \textcolor{keyword}{enum} video\_file\_type file\_type = input->file\_type;
152   y4m\_input *y4m = &input->y4m;
153   \textcolor{keyword}{struct }detect\_buffer *detect = &input->detect;
154   \textcolor{keywordtype}{int} plane = 0;
155   \textcolor{keywordtype}{int} shortread = 0;
156 
157   \textcolor{keywordflow}{if} (file\_type == FILE\_TYPE\_Y4M) \{
158     \textcolor{keywordflow}{if} (y4m\_input\_fetch\_frame(y4m, f, img) < 1)
159       \textcolor{keywordflow}{return} 0;
160   \} \textcolor{keywordflow}{else} \{
161     \textcolor{keywordflow}{if} (file\_type == FILE\_TYPE\_IVF) \{
162       \textcolor{keywordtype}{char} junk[IVF\_FRAME\_HDR\_SZ];
163 
164       \textcolor{comment}{/* Skip the frame header. We know how big the frame should be. See}
165 \textcolor{comment}{       * write\_ivf\_frame\_header() for documentation on the frame header}
166 \textcolor{comment}{       * layout.}
167 \textcolor{comment}{       */}
168       (void) fread(junk, 1, IVF\_FRAME\_HDR\_SZ, f);
169     \}
170 
171     \textcolor{keywordflow}{for} (plane = 0; plane < 3; plane++) \{
172       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptr;
173       \textcolor{keywordtype}{int} w = (plane ? (1 + img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}) / 2 : img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w});
174       \textcolor{keywordtype}{int} h = (plane ? (1 + img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}) / 2 : img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h});
175       \textcolor{keywordtype}{int} r;
176 
177       \textcolor{comment}{/* Determine the correct plane based on the image format. The for-loop}
178 \textcolor{comment}{       * always counts in Y,U,V order, but this may not match the order of}
179 \textcolor{comment}{       * the data on disk.}
180 \textcolor{comment}{       */}
181       \textcolor{keywordflow}{switch} (plane) \{
182         \textcolor{keywordflow}{case} 1:
183           ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193a6e4e8961bbcf96478c300dc4c3e1dc18}{VPX\_IMG\_FMT\_YV12} ? 
      \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V} : \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}];
184           \textcolor{keywordflow}{break};
185         \textcolor{keywordflow}{case} 2:
186           ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[img->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193a6e4e8961bbcf96478c300dc4c3e1dc18}{VPX\_IMG\_FMT\_YV12} ? 
      \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U} : \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}];
187           \textcolor{keywordflow}{break};
188         \textcolor{keywordflow}{default}:
189           ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[plane];
190       \}
191 
192       \textcolor{keywordflow}{for} (r = 0; r < h; r++) \{
193         \textcolor{keywordtype}{size\_t} needed = w;
194         \textcolor{keywordtype}{size\_t} buf\_position = 0;
195         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} left = detect->buf\_read - detect->position;
196         \textcolor{keywordflow}{if} (left > 0) \{
197           \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} more = (left < needed) ? left : needed;
198           memcpy(ptr, detect->buf + detect->position, more);
199           buf\_position = more;
200           needed -= more;
201           detect->position += more;
202         \}
203         \textcolor{keywordflow}{if} (needed > 0) \{
204           shortread |= (fread(ptr + buf\_position, 1, needed, f) < needed);
205         \}
206 
207         ptr += img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[plane];
208       \}
209     \}
210   \}
211 
212   \textcolor{keywordflow}{return} !shortread;
213 \}
214 
215 
216 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_is\_y4m(FILE      *infile,
217                          y4m\_input *y4m,
218                          \textcolor{keywordtype}{char}       detect[4]) \{
219   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"YUV4"}, 4) == 0) \{
220     \textcolor{keywordflow}{return} 1;
221   \}
222   \textcolor{keywordflow}{return} 0;
223 \}
224 
225 \textcolor{preprocessor}{#define IVF\_FILE\_HDR\_SZ (32)}
226 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_is\_ivf(\textcolor{keyword}{struct} input\_state *input,
227                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *fourcc) \{
228   \textcolor{keywordtype}{char} raw\_hdr[IVF\_FILE\_HDR\_SZ];
229   \textcolor{keywordtype}{int} is\_ivf = 0;
230   FILE *infile = input->file;
231   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *width = &input->w;
232   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *height = &input->h;
233   \textcolor{keyword}{struct }detect\_buffer *detect = &input->detect;
234 
235   \textcolor{keywordflow}{if} (memcmp(detect->buf, \textcolor{stringliteral}{"DKIF"}, 4) != 0)
236     \textcolor{keywordflow}{return} 0;
237 
238   \textcolor{comment}{/* See write\_ivf\_file\_header() for more documentation on the file header}
239 \textcolor{comment}{   * layout.}
240 \textcolor{comment}{   */}
241   \textcolor{keywordflow}{if} (fread(raw\_hdr + 4, 1, IVF\_FILE\_HDR\_SZ - 4, infile)
242       == IVF\_FILE\_HDR\_SZ - 4) \{
243     \{
244       is\_ivf = 1;
245 
246       \textcolor{keywordflow}{if} (mem\_get\_le16(raw\_hdr + 4) != 0)
247         warn(\textcolor{stringliteral}{"Unrecognized IVF version! This file may not decode "}
248              \textcolor{stringliteral}{"properly."});
249 
250       *fourcc = mem\_get\_le32(raw\_hdr + 8);
251     \}
252   \}
253 
254   \textcolor{keywordflow}{if} (is\_ivf) \{
255     *width = mem\_get\_le16(raw\_hdr + 12);
256     *height = mem\_get\_le16(raw\_hdr + 14);
257     detect->position = 4;
258   \}
259 
260   \textcolor{keywordflow}{return} is\_ivf;
261 \}
262 
263 
264 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_file\_header(FILE *outfile,
265                                   \textcolor{keyword}{const} \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *cfg,
266                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc,
267                                   \textcolor{keywordtype}{int} frame\_cnt) \{
268   \textcolor{keywordtype}{char} header[32];
269 
270   \textcolor{keywordflow}{if} (cfg->\hyperlink{structvpx__codec__enc__cfg_a70d62d87aae7d1168746577f14a6dccf}{g\_pass} != \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa7b6943a41868e8e26a77e9500f139ca1}{VPX\_RC\_ONE\_PASS} && cfg->\hyperlink{structvpx__codec__enc__cfg_a70d62d87aae7d1168746577f14a6dccf}{g\_pass} != 
      \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa65da543b956d6a9b1f301ab8cc90d3a7}{VPX\_RC\_LAST\_PASS})
271     \textcolor{keywordflow}{return};
272 
273   header[0] = \textcolor{charliteral}{'D'};
274   header[1] = \textcolor{charliteral}{'K'};
275   header[2] = \textcolor{charliteral}{'I'};
276   header[3] = \textcolor{charliteral}{'F'};
277   mem\_put\_le16(header + 4,  0);                 \textcolor{comment}{/* version */}
278   mem\_put\_le16(header + 6,  32);                \textcolor{comment}{/* headersize */}
279   mem\_put\_le32(header + 8,  fourcc);            \textcolor{comment}{/* headersize */}
280   mem\_put\_le16(header + 12, cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w});          \textcolor{comment}{/* width */}
281   mem\_put\_le16(header + 14, cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h});          \textcolor{comment}{/* height */}
282   mem\_put\_le32(header + 16, cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den}); \textcolor{comment}{/* rate */}
283   mem\_put\_le32(header + 20, cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num}); \textcolor{comment}{/* scale */}
284   mem\_put\_le32(header + 24, frame\_cnt);         \textcolor{comment}{/* length */}
285   mem\_put\_le32(header + 28, 0);                 \textcolor{comment}{/* unused */}
286 
287   (void) fwrite(header, 1, 32, outfile);
288 \}
289 
290 
291 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_frame\_header(FILE *outfile,
292                                    \textcolor{keyword}{const} \hyperlink{structvpx__codec__cx__pkt}{vpx\_codec\_cx\_pkt\_t} *pkt) \{
293   \textcolor{keywordtype}{char}             header[12];
294   \hyperlink{group__encoder_ga7e711b0a71c65aef8f0faea8bd57b05f}{vpx\_codec\_pts\_t}  pts;
295 
296   \textcolor{keywordflow}{if} (pkt->\hyperlink{structvpx__codec__cx__pkt_a41f395b39516343c1329a4a85a0084f2}{kind} != \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a2261aae5594289400e812fb1e6b6b0cc}{VPX\_CODEC\_CX\_FRAME\_PKT})
297     \textcolor{keywordflow}{return};
298 
299   pts = pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.pts;
300   mem\_put\_le32(header, (\textcolor{keywordtype}{int})pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz);
301   mem\_put\_le32(header + 4, pts & 0xFFFFFFFF);
302   mem\_put\_le32(header + 8, pts >> 32);
303 
304   (void) fwrite(header, 1, 12, outfile);
305 \}
306 
307 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_frame\_size(FILE *outfile, \textcolor{keywordtype}{size\_t} size) \{
308   \textcolor{keywordtype}{char}             header[4];
309   mem\_put\_le32(header, (\textcolor{keywordtype}{int})size);
310   (void) fwrite(header, 1, 4, outfile);
311 \}
312 
313 
314 
315 \textcolor{comment}{/* Murmur hash derived from public domain reference implementation at}
316 \textcolor{comment}{ *   http:// sites.google.com/site/murmurhash/}
317 \textcolor{comment}{ */}
318 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} murmur(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} seed) \{
319   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} m = 0x5bd1e995;
320   \textcolor{keyword}{const} \textcolor{keywordtype}{int} r = 24;
321 
322   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h = seed ^ len;
323 
324   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)key;
325 
326   \textcolor{keywordflow}{while} (len >= 4) \{
327     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} k;
328 
329     k  = (\textcolor{keywordtype}{unsigned} int)data[0];
330     k |= (\textcolor{keywordtype}{unsigned} int)data[1] << 8;
331     k |= (\textcolor{keywordtype}{unsigned} int)data[2] << 16;
332     k |= (\textcolor{keywordtype}{unsigned} int)data[3] << 24;
333 
334     k *= m;
335     k ^= k >> r;
336     k *= m;
337 
338     h *= m;
339     h ^= k;
340 
341     data += 4;
342     len -= 4;
343   \}
344 
345   \textcolor{keywordflow}{switch} (len) \{
346     \textcolor{keywordflow}{case} 3:
347       h ^= data[2] << 16;
348     \textcolor{keywordflow}{case} 2:
349       h ^= data[1] << 8;
350     \textcolor{keywordflow}{case} 1:
351       h ^= data[0];
352       h *= m;
353   \};
354 
355   h ^= h >> 13;
356   h *= m;
357   h ^= h >> 15;
358 
359   \textcolor{keywordflow}{return} h;
360 \}
361 
362 
363 \textcolor{preprocessor}{#include "args.h"}
364 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t debugmode = ARG\_DEF(\textcolor{stringliteral}{"D"}, \textcolor{stringliteral}{"debug"}, 0,
365                                            \textcolor{stringliteral}{"Debug mode (makes output deterministic)"});
366 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile = ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1,
367                                             \textcolor{stringliteral}{"Output filename"});
368 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 = ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0,
369                                           \textcolor{stringliteral}{"Input file is YV12 "});
370 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 = ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0,
371                                           \textcolor{stringliteral}{"Input file is I420 (default)"});
372 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1,
373                                           \textcolor{stringliteral}{"Codec to use"});
374 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t passes           = ARG\_DEF(\textcolor{stringliteral}{"p"}, \textcolor{stringliteral}{"passes"}, 1,
375                                                   \textcolor{stringliteral}{"Number of passes (1/2)"});
376 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pass\_arg         = ARG\_DEF(NULL, \textcolor{stringliteral}{"pass"}, 1,
377                                                   \textcolor{stringliteral}{"Pass to execute (1/2)"});
378 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpf\_name         = ARG\_DEF(NULL, \textcolor{stringliteral}{"fpf"}, 1,
379                                                   \textcolor{stringliteral}{"First pass statistics file name"});
380 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limit = ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1,
381                                        \textcolor{stringliteral}{"Stop encoding after n input frames"});
382 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip = ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1,
383                                       \textcolor{stringliteral}{"Skip the first n input frames"});
384 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deadline         = ARG\_DEF(\textcolor{stringliteral}{"d"}, \textcolor{stringliteral}{"deadline"}, 1,
385                                                   \textcolor{stringliteral}{"Deadline per frame (usec)"});
386 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t best\_dl          = ARG\_DEF(NULL, \textcolor{stringliteral}{"best"}, 0,
387                                                   \textcolor{stringliteral}{"Use Best Quality Deadline"});
388 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t good\_dl          = ARG\_DEF(NULL, \textcolor{stringliteral}{"good"}, 0,
389                                                   \textcolor{stringliteral}{"Use Good Quality Deadline"});
390 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rt\_dl            = ARG\_DEF(NULL, \textcolor{stringliteral}{"rt"}, 0,
391                                                   \textcolor{stringliteral}{"Use Realtime Quality Deadline"});
392 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quietarg         = ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quiet"}, 0,
393                                                   \textcolor{stringliteral}{"Do not print encode progress"});
394 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg       = ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0,
395                                                   \textcolor{stringliteral}{"Show encoder parameters"});
396 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t psnrarg          = ARG\_DEF(NULL, \textcolor{stringliteral}{"psnr"}, 0,
397                                                   \textcolor{stringliteral}{"Show PSNR in status line"});
398 \textcolor{keyword}{enum} TestDecodeFatality \{
399   TEST\_DECODE\_OFF,
400   TEST\_DECODE\_FATAL,
401   TEST\_DECODE\_WARN,
402 \};
403 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list test\_decode\_enum[] = \{
404   \{\textcolor{stringliteral}{"off"},   TEST\_DECODE\_OFF\},
405   \{\textcolor{stringliteral}{"fatal"}, TEST\_DECODE\_FATAL\},
406   \{\textcolor{stringliteral}{"warn"},  TEST\_DECODE\_WARN\},
407   \{NULL, 0\}
408 \};
409 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t recontest = ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"test-decode"}, 1,
410                                                 \textcolor{stringliteral}{"Test encode/decode mismatch"},
411                                                 test\_decode\_enum);
412 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framerate        = ARG\_DEF(NULL, \textcolor{stringliteral}{"fps"}, 1,
413                                                   \textcolor{stringliteral}{"Stream frame rate (rate/scale)"});
414 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_ivf          = ARG\_DEF(NULL, \textcolor{stringliteral}{"ivf"}, 0,
415                                                   \textcolor{stringliteral}{"Output IVF (default is WebM)"});
416 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t out\_part = ARG\_DEF(\textcolor{stringliteral}{"P"}, \textcolor{stringliteral}{"output-partitions"}, 0,
417                                           \textcolor{stringliteral}{"Makes encoder output partitions. Requires IVF output!"});
418 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t q\_hist\_n         = ARG\_DEF(NULL, \textcolor{stringliteral}{"q-hist"}, 1,
419                                                   \textcolor{stringliteral}{"Show quantizer histogram (n-buckets)"});
420 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rate\_hist\_n         = ARG\_DEF(NULL, \textcolor{stringliteral}{"rate-hist"}, 1,
421                                                      \textcolor{stringliteral}{"Show rate histogram (n-buckets)"});
422 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *main\_args[] = \{
423   &debugmode,
424   &outputfile, &codecarg, &passes, &pass\_arg, &fpf\_name, &limit, &skip,
425   &deadline, &best\_dl, &good\_dl, &rt\_dl,
426   &quietarg, &verbosearg, &psnrarg, &use\_ivf, &out\_part, &q\_hist\_n, &rate\_hist\_n,
427   NULL
428 \};
429 
430 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t usage            = ARG\_DEF(\textcolor{stringliteral}{"u"}, \textcolor{stringliteral}{"usage"}, 1,
431                                                   \textcolor{stringliteral}{"Usage profile number to use"});
432 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threads          = ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1,
433                                                   \textcolor{stringliteral}{"Max number of threads to use"});
434 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t profile          = ARG\_DEF(NULL, \textcolor{stringliteral}{"profile"}, 1,
435                                                   \textcolor{stringliteral}{"Bitstream profile number to use"});
436 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width            = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1,
437                                                   \textcolor{stringliteral}{"Frame width"});
438 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height           = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1,
439                                                   \textcolor{stringliteral}{"Frame height"});
440 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list stereo\_mode\_enum[] = \{
441   \{\textcolor{stringliteral}{"mono"}, STEREO\_FORMAT\_MONO\},
442   \{\textcolor{stringliteral}{"left-right"}, STEREO\_FORMAT\_LEFT\_RIGHT\},
443   \{\textcolor{stringliteral}{"bottom-top"}, STEREO\_FORMAT\_BOTTOM\_TOP\},
444   \{\textcolor{stringliteral}{"top-bottom"}, STEREO\_FORMAT\_TOP\_BOTTOM\},
445   \{\textcolor{stringliteral}{"right-left"}, STEREO\_FORMAT\_RIGHT\_LEFT\},
446   \{NULL, 0\}
447 \};
448 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t stereo\_mode      = ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"stereo-mode"}, 1,
449                                                        \textcolor{stringliteral}{"Stereo 3D video format"}, stereo\_mode\_enum);
450 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase         = ARG\_DEF(NULL, \textcolor{stringliteral}{"timebase"}, 1,
451                                                   \textcolor{stringliteral}{"Output timestamp precision (fractional seconds)"});
452 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_resilient  = ARG\_DEF(NULL, \textcolor{stringliteral}{"error-resilient"}, 1,
453                                                   \textcolor{stringliteral}{"Enable error resiliency features"});
454 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lag\_in\_frames    = ARG\_DEF(NULL, \textcolor{stringliteral}{"lag-in-frames"}, 1,
455                                                   \textcolor{stringliteral}{"Max number of frames to lag"});
456 
457 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *global\_args[] = \{
458   &use\_yv12, &use\_i420, &usage, &threads, &profile,
459   &width, &height, &stereo\_mode, &timebase, &framerate,
460   &error\_resilient,
461   &lag\_in\_frames, NULL
462 \};
463 
464 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dropframe\_thresh   = ARG\_DEF(NULL, \textcolor{stringliteral}{"drop-frame"}, 1,
465                                                     \textcolor{stringliteral}{"Temporal resampling threshold (buf %)"});
466 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_allowed     = ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-allowed"}, 1,
467                                                     \textcolor{stringliteral}{"Spatial resampling enabled (bool)"});
468 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_up\_thresh   = ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-up"}, 1,
469                                                     \textcolor{stringliteral}{"Upscale threshold (buf %)"});
470 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_down\_thresh = ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-down"}, 1,
471                                                     \textcolor{stringliteral}{"Downscale threshold (buf %)"});
472 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list end\_usage\_enum[] = \{
473   \{\textcolor{stringliteral}{"vbr"}, \hyperlink{group__encoder_ggaf50e74d91be4cae6f70dfeba5b7410d2ab8fbe4441ed3f31a167c8194e8a64f87}{VPX\_VBR}\},
474   \{\textcolor{stringliteral}{"cbr"}, \hyperlink{group__encoder_ggaf50e74d91be4cae6f70dfeba5b7410d2a8b02853cb35790d60cc171a11f6c268a}{VPX\_CBR}\},
475   \{\textcolor{stringliteral}{"cq"},  \hyperlink{group__encoder_ggaf50e74d91be4cae6f70dfeba5b7410d2a5f2fd02b55c67d62bfd79380bcb03f63}{VPX\_CQ}\},
476   \{\textcolor{stringliteral}{"q"},   \hyperlink{group__encoder_ggaf50e74d91be4cae6f70dfeba5b7410d2a5ebb5564dc5e8ec99d3c6221d89b8858}{VPX\_Q}\},
477   \{NULL, 0\}
478 \};
479 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t end\_usage          = ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"end-usage"}, 1,
480                                                          \textcolor{stringliteral}{"Rate control mode"}, end\_usage\_enum);
481 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_bitrate     = ARG\_DEF(NULL, \textcolor{stringliteral}{"target-bitrate"}, 1,
482                                                     \textcolor{stringliteral}{"Bitrate (kbps)"});
483 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_quantizer      = ARG\_DEF(NULL, \textcolor{stringliteral}{"min-q"}, 1,
484                                                     \textcolor{stringliteral}{"Minimum (best) quantizer"});
485 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_quantizer      = ARG\_DEF(NULL, \textcolor{stringliteral}{"max-q"}, 1,
486                                                     \textcolor{stringliteral}{"Maximum (worst) quantizer"});
487 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t undershoot\_pct     = ARG\_DEF(NULL, \textcolor{stringliteral}{"undershoot-pct"}, 1,
488                                                     \textcolor{stringliteral}{"Datarate undershoot (min) target (%)"});
489 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t overshoot\_pct      = ARG\_DEF(NULL, \textcolor{stringliteral}{"overshoot-pct"}, 1,
490                                                     \textcolor{stringliteral}{"Datarate overshoot (max) target (%)"});
491 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_sz             = ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-sz"}, 1,
492                                                     \textcolor{stringliteral}{"Client buffer size (ms)"});
493 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_initial\_sz     = ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-initial-sz"}, 1,
494                                                     \textcolor{stringliteral}{"Client initial buffer size (ms)"});
495 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_optimal\_sz     = ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-optimal-sz"}, 1,
496                                                     \textcolor{stringliteral}{"Client optimal buffer size (ms)"});
497 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_args[] = \{
498   &dropframe\_thresh, &resize\_allowed, &resize\_up\_thresh, &resize\_down\_thresh,
499   &end\_usage, &target\_bitrate, &min\_quantizer, &max\_quantizer,
500   &undershoot\_pct, &overshoot\_pct, &buf\_sz, &buf\_initial\_sz, &buf\_optimal\_sz,
501   NULL
502 \};
503 
504 
505 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bias\_pct = ARG\_DEF(NULL, \textcolor{stringliteral}{"bias-pct"}, 1,
506                                           \textcolor{stringliteral}{"CBR/VBR bias (0=CBR, 100=VBR)"});
507 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t minsection\_pct = ARG\_DEF(NULL, \textcolor{stringliteral}{"minsection-pct"}, 1,
508                                                 \textcolor{stringliteral}{"GOP min bitrate (% of target)"});
509 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t maxsection\_pct = ARG\_DEF(NULL, \textcolor{stringliteral}{"maxsection-pct"}, 1,
510                                                 \textcolor{stringliteral}{"GOP max bitrate (% of target)"});
511 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_twopass\_args[] = \{
512   &bias\_pct, &minsection\_pct, &maxsection\_pct, NULL
513 \};
514 
515 
516 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_min\_dist = ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-min-dist"}, 1,
517                                              \textcolor{stringliteral}{"Minimum keyframe interval (frames)"});
518 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_max\_dist = ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-max-dist"}, 1,
519                                              \textcolor{stringliteral}{"Maximum keyframe interval (frames)"});
520 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_disabled = ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-kf"}, 0,
521                                              \textcolor{stringliteral}{"Disable keyframe placement"});
522 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *kf\_args[] = \{
523   &kf\_min\_dist, &kf\_max\_dist, &kf\_disabled, NULL
524 \};
525 
526 
527 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noise\_sens = ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-sensitivity"}, 1,
528                                             \textcolor{stringliteral}{"Noise sensitivity (frames to blur)"});
529 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sharpness = ARG\_DEF(NULL, \textcolor{stringliteral}{"sharpness"}, 1,
530                                            \textcolor{stringliteral}{"Filter sharpness (0-7)"});
531 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t static\_thresh = ARG\_DEF(NULL, \textcolor{stringliteral}{"static-thresh"}, 1,
532                                                \textcolor{stringliteral}{"Motion detection threshold"});
533 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cpu\_used = ARG\_DEF(NULL, \textcolor{stringliteral}{"cpu-used"}, 1,
534                                           \textcolor{stringliteral}{"CPU Used (-16..16)"});
535 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t token\_parts = ARG\_DEF(NULL, \textcolor{stringliteral}{"token-parts"}, 1,
536                                      \textcolor{stringliteral}{"Number of token partitions to use, log2"});
537 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_cols = ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-columns"}, 1,
538                                          \textcolor{stringliteral}{"Number of tile columns to use, log2"});
539 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_rows = ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-rows"}, 1,
540                                            \textcolor{stringliteral}{"Number of tile rows to use, log2"});
541 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t auto\_altref = ARG\_DEF(NULL, \textcolor{stringliteral}{"auto-alt-ref"}, 1,
542                                              \textcolor{stringliteral}{"Enable automatic alt reference frames"});
543 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_maxframes = ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-maxframes"}, 1,
544                                                 \textcolor{stringliteral}{"AltRef Max Frames"});
545 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_strength = ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-strength"}, 1,
546                                                \textcolor{stringliteral}{"AltRef Strength"});
547 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_type = ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-type"}, 1,
548                                            \textcolor{stringliteral}{"AltRef Type"});
549 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tuning\_enum[] = \{
550   \{\textcolor{stringliteral}{"psnr"}, VP8\_TUNE\_PSNR\},
551   \{\textcolor{stringliteral}{"ssim"}, VP8\_TUNE\_SSIM\},
552   \{NULL, 0\}
553 \};
554 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_ssim = ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"tune"}, 1,
555                                                 \textcolor{stringliteral}{"Material to favor"}, tuning\_enum);
556 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cq\_level = ARG\_DEF(NULL, \textcolor{stringliteral}{"cq-level"}, 1,
557                                           \textcolor{stringliteral}{"Constant/Constrained Quality level"});
558 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_intra\_rate\_pct = ARG\_DEF(NULL, \textcolor{stringliteral}{"max-intra-rate"}, 1,
559                                                     \textcolor{stringliteral}{"Max I-frame bitrate (pct)"});
560 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lossless = ARG\_DEF(NULL, \textcolor{stringliteral}{"lossless"}, 1, \textcolor{stringliteral}{"Lossless mode"});
561 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER}
562 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_parallel\_decoding  = ARG\_DEF(
563     NULL, \textcolor{stringliteral}{"frame-parallel"}, 1, \textcolor{stringliteral}{"Enable frame parallel decodability features"});
564 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t aq\_mode  = ARG\_DEF(
565     NULL, \textcolor{stringliteral}{"aq-mode"}, 1,
566     \textcolor{stringliteral}{"Adaptive quantization mode (0: disabled (by default), 1: variance based)"});
567 \textcolor{preprocessor}{#endif}
568 
569 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER}
570 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *vp8\_args[] = \{
571   &cpu\_used, &auto\_altref, &noise\_sens, &sharpness, &static\_thresh,
572   &token\_parts, &arnr\_maxframes, &arnr\_strength, &arnr\_type,
573   &tune\_ssim, &cq\_level, &max\_intra\_rate\_pct,
574   NULL
575 \};
576 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} vp8\_arg\_ctrl\_map[] = \{
577   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca953ff0eaa2fcdc2ecd627e449b026853}{VP8E\_SET\_CPUUSED}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca24a5530efabb8b4949d01622b1d72cb0}{VP8E\_SET\_ENABLEAUTOALTREF},
578   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca3fa90cb70bade72af3c2d8d91471a36c}{VP8E\_SET\_NOISE\_SENSITIVITY}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca815930923fff388825ee3cc4ef69bb28}{VP8E\_SET\_SHARPNESS}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecab34559df04d3d662616300ed0682dcfd}{VP8E\_SET\_STATIC\_THRESHOLD},
579   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca462a4f14f39a6eb5c4a4004fc8d0ad75}{VP8E\_SET\_TOKEN\_PARTITIONS},
580   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca628d73f1a69fadd8aa57e0dfef578da8}{VP8E\_SET\_ARNR\_MAXFRAMES}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca0a8c40a768af935ae73faa53355c3244}{VP8E\_SET\_ARNR\_STRENGTH}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca4e0a0af58670012026c213083cd48f3a}{VP8E\_SET\_ARNR\_TYPE},
581   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca126ccbe7bde63b59cec5ea68a82dd498}{VP8E\_SET\_TUNING}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecacd4f5b730bddb9788c3d0b82218ec503}{VP8E\_SET\_CQ\_LEVEL}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca09c69ff4a3aabdb307d4f24027dfc4c1}{VP8E\_SET\_MAX\_INTRA\_BITRATE\_PCT},
582   0
583 \};
584 \textcolor{preprocessor}{#endif}
585 
586 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER}
587 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *vp9\_args[] = \{
588   &cpu\_used, &auto\_altref, &noise\_sens, &sharpness, &static\_thresh,
589   &tile\_cols, &tile\_rows, &arnr\_maxframes, &arnr\_strength, &arnr\_type,
590   &tune\_ssim, &cq\_level, &max\_intra\_rate\_pct, &lossless,
591   &frame\_parallel\_decoding, &aq\_mode,
592   NULL
593 \};
594 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} vp9\_arg\_ctrl\_map[] = \{
595   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca953ff0eaa2fcdc2ecd627e449b026853}{VP8E\_SET\_CPUUSED}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca24a5530efabb8b4949d01622b1d72cb0}{VP8E\_SET\_ENABLEAUTOALTREF},
596   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca3fa90cb70bade72af3c2d8d91471a36c}{VP8E\_SET\_NOISE\_SENSITIVITY}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca815930923fff388825ee3cc4ef69bb28}{VP8E\_SET\_SHARPNESS}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecab34559df04d3d662616300ed0682dcfd}{VP8E\_SET\_STATIC\_THRESHOLD},
597   VP9E\_SET\_TILE\_COLUMNS, VP9E\_SET\_TILE\_ROWS,
598   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca628d73f1a69fadd8aa57e0dfef578da8}{VP8E\_SET\_ARNR\_MAXFRAMES}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca0a8c40a768af935ae73faa53355c3244}{VP8E\_SET\_ARNR\_STRENGTH}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca4e0a0af58670012026c213083cd48f3a}{VP8E\_SET\_ARNR\_TYPE},
599   \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca126ccbe7bde63b59cec5ea68a82dd498}{VP8E\_SET\_TUNING}, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecacd4f5b730bddb9788c3d0b82218ec503}{VP8E\_SET\_CQ\_LEVEL}, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca09c69ff4a3aabdb307d4f24027dfc4c1}{VP8E\_SET\_MAX\_INTRA\_BITRATE\_PCT},
600   VP9E\_SET\_LOSSLESS, VP9E\_SET\_FRAME\_PARALLEL\_DECODING, VP9E\_SET\_AQ\_MODE,
601   0
602 \};
603 \textcolor{preprocessor}{#endif}
604 
605 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *no\_args[] = \{ NULL \};
606 
607 \textcolor{keywordtype}{void} usage\_exit() \{
608   \textcolor{keywordtype}{int} i;
609 
610   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <options> -o dst\_filename src\_filename \(\backslash\)n"},
611           exec\_name);
612 
613   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nOptions:\(\backslash\)n"});
614   arg\_show\_usage(stderr, main\_args);
615   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nEncoder Global Options:\(\backslash\)n"});
616   arg\_show\_usage(stderr, global\_args);
617   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nRate Control Options:\(\backslash\)n"});
618   arg\_show\_usage(stderr, rc\_args);
619   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nTwopass Rate Control Options:\(\backslash\)n"});
620   arg\_show\_usage(stderr, rc\_twopass\_args);
621   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nKeyframe Placement Options:\(\backslash\)n"});
622   arg\_show\_usage(stderr, kf\_args);
623 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER}
624   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nVP8 Specific Options:\(\backslash\)n"});
625   arg\_show\_usage(stderr, vp8\_args);
626 \textcolor{preprocessor}{#endif}
627 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER}
628   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nVP9 Specific Options:\(\backslash\)n"});
629   arg\_show\_usage(stderr, vp9\_args);
630 \textcolor{preprocessor}{#endif}
631   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream timebase (--timebase):\(\backslash\)n"}
632           \textcolor{stringliteral}{"  The desired precision of timestamps in the output, expressed\(\backslash\)n"}
633           \textcolor{stringliteral}{"  in fractional seconds. Default is 1/1000.\(\backslash\)n"});
634   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"}
635           \textcolor{stringliteral}{"Included encoders:\(\backslash\)n"}
636           \textcolor{stringliteral}{"\(\backslash\)n"});
637 
638   \textcolor{keywordflow}{for} (i = 0; i < \textcolor{keyword}{sizeof}(codecs) / \textcolor{keyword}{sizeof}(codecs[0]); i++)
639     fprintf(stderr, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"},
640             codecs[i].name,
641             \hyperlink{group__codec_ga9eee39f450d8cdcf5aba0e2bda6e5aa8}{vpx\_codec\_iface\_name}(codecs[i].iface()));
642 
643   exit(EXIT\_FAILURE);
644 \}
645 
646 
647 \textcolor{preprocessor}{#define HIST\_BAR\_MAX 40}
648 \textcolor{keyword}{struct }hist\_bucket \{
649   \textcolor{keywordtype}{int} low, high, count;
650 \};
651 
652 
653 \textcolor{keyword}{static} \textcolor{keywordtype}{int} merge\_hist\_buckets(\textcolor{keyword}{struct} hist\_bucket *bucket,
654                               \textcolor{keywordtype}{int} *buckets\_,
655                               \textcolor{keywordtype}{int} max\_buckets) \{
656   \textcolor{keywordtype}{int} small\_bucket = 0, merge\_bucket = INT\_MAX, big\_bucket = 0;
657   \textcolor{keywordtype}{int} buckets = *buckets\_;
658   \textcolor{keywordtype}{int} i;
659 
660   \textcolor{comment}{/* Find the extrema for this list of buckets */}
661   big\_bucket = small\_bucket = 0;
662   \textcolor{keywordflow}{for} (i = 0; i < buckets; i++) \{
663     \textcolor{keywordflow}{if} (bucket[i].count < bucket[small\_bucket].count)
664       small\_bucket = i;
665     \textcolor{keywordflow}{if} (bucket[i].count > bucket[big\_bucket].count)
666       big\_bucket = i;
667   \}
668 
669   \textcolor{comment}{/* If we have too many buckets, merge the smallest with an adjacent}
670 \textcolor{comment}{   * bucket.}
671 \textcolor{comment}{   */}
672   \textcolor{keywordflow}{while} (buckets > max\_buckets) \{
673     \textcolor{keywordtype}{int} last\_bucket = buckets - 1;
674 
675     \textcolor{comment}{/* merge the small bucket with an adjacent one. */}
676     \textcolor{keywordflow}{if} (small\_bucket == 0)
677       merge\_bucket = 1;
678     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (small\_bucket == last\_bucket)
679       merge\_bucket = last\_bucket - 1;
680     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bucket[small\_bucket - 1].count < bucket[small\_bucket + 1].count)
681       merge\_bucket = small\_bucket - 1;
682     \textcolor{keywordflow}{else}
683       merge\_bucket = small\_bucket + 1;
684 
685     assert(abs(merge\_bucket - small\_bucket) <= 1);
686     assert(small\_bucket < buckets);
687     assert(big\_bucket < buckets);
688     assert(merge\_bucket < buckets);
689 
690     \textcolor{keywordflow}{if} (merge\_bucket < small\_bucket) \{
691       bucket[merge\_bucket].high = bucket[small\_bucket].high;
692       bucket[merge\_bucket].count += bucket[small\_bucket].count;
693     \} \textcolor{keywordflow}{else} \{
694       bucket[small\_bucket].high = bucket[merge\_bucket].high;
695       bucket[small\_bucket].count += bucket[merge\_bucket].count;
696       merge\_bucket = small\_bucket;
697     \}
698 
699     assert(bucket[merge\_bucket].low != bucket[merge\_bucket].high);
700 
701     buckets--;
702 
703     \textcolor{comment}{/* Remove the merge\_bucket from the list, and find the new small}
704 \textcolor{comment}{     * and big buckets while we're at it}
705 \textcolor{comment}{     */}
706     big\_bucket = small\_bucket = 0;
707     \textcolor{keywordflow}{for} (i = 0; i < buckets; i++) \{
708       \textcolor{keywordflow}{if} (i > merge\_bucket)
709         bucket[i] = bucket[i + 1];
710 
711       \textcolor{keywordflow}{if} (bucket[i].count < bucket[small\_bucket].count)
712         small\_bucket = i;
713       \textcolor{keywordflow}{if} (bucket[i].count > bucket[big\_bucket].count)
714         big\_bucket = i;
715     \}
716 
717   \}
718 
719   *buckets\_ = buckets;
720   \textcolor{keywordflow}{return} bucket[big\_bucket].count;
721 \}
722 
723 
724 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_histogram(\textcolor{keyword}{const} \textcolor{keyword}{struct} hist\_bucket *bucket,
725                            \textcolor{keywordtype}{int}                       buckets,
726                            \textcolor{keywordtype}{int}                       total,
727                            \textcolor{keywordtype}{int}                       scale) \{
728   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pat1, *pat2;
729   \textcolor{keywordtype}{int} i;
730 
731   \textcolor{keywordflow}{switch} ((\textcolor{keywordtype}{int})(log(bucket[buckets - 1].high) / log(10)) + 1) \{
732     \textcolor{keywordflow}{case} 1:
733     \textcolor{keywordflow}{case} 2:
734       pat1 = \textcolor{stringliteral}{"%4d %2s: "};
735       pat2 = \textcolor{stringliteral}{"%4d-%2d: "};
736       \textcolor{keywordflow}{break};
737     \textcolor{keywordflow}{case} 3:
738       pat1 = \textcolor{stringliteral}{"%5d %3s: "};
739       pat2 = \textcolor{stringliteral}{"%5d-%3d: "};
740       \textcolor{keywordflow}{break};
741     \textcolor{keywordflow}{case} 4:
742       pat1 = \textcolor{stringliteral}{"%6d %4s: "};
743       pat2 = \textcolor{stringliteral}{"%6d-%4d: "};
744       \textcolor{keywordflow}{break};
745     \textcolor{keywordflow}{case} 5:
746       pat1 = \textcolor{stringliteral}{"%7d %5s: "};
747       pat2 = \textcolor{stringliteral}{"%7d-%5d: "};
748       \textcolor{keywordflow}{break};
749     \textcolor{keywordflow}{case} 6:
750       pat1 = \textcolor{stringliteral}{"%8d %6s: "};
751       pat2 = \textcolor{stringliteral}{"%8d-%6d: "};
752       \textcolor{keywordflow}{break};
753     \textcolor{keywordflow}{case} 7:
754       pat1 = \textcolor{stringliteral}{"%9d %7s: "};
755       pat2 = \textcolor{stringliteral}{"%9d-%7d: "};
756       \textcolor{keywordflow}{break};
757     \textcolor{keywordflow}{default}:
758       pat1 = \textcolor{stringliteral}{"%12d %10s: "};
759       pat2 = \textcolor{stringliteral}{"%12d-%10d: "};
760       \textcolor{keywordflow}{break};
761   \}
762 
763   \textcolor{keywordflow}{for} (i = 0; i < buckets; i++) \{
764     \textcolor{keywordtype}{int} len;
765     \textcolor{keywordtype}{int} j;
766     \textcolor{keywordtype}{float} pct;
767 
768     pct = (float)(100.0 * bucket[i].count / total);
769     len = HIST\_BAR\_MAX * bucket[i].count / scale;
770     \textcolor{keywordflow}{if} (len < 1)
771       len = 1;
772     assert(len <= HIST\_BAR\_MAX);
773 
774     \textcolor{keywordflow}{if} (bucket[i].low == bucket[i].high)
775       fprintf(stderr, pat1, bucket[i].low, \textcolor{stringliteral}{""});
776     \textcolor{keywordflow}{else}
777       fprintf(stderr, pat2, bucket[i].low, bucket[i].high);
778 
779     \textcolor{keywordflow}{for} (j = 0; j < HIST\_BAR\_MAX; j++)
780       fprintf(stderr, j < len ? \textcolor{stringliteral}{"="} : \textcolor{stringliteral}{" "});
781     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)t%5d (%6.2f%%)\(\backslash\)n"}, bucket[i].count, pct);
782   \}
783 \}
784 
785 
786 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_q\_histogram(\textcolor{keyword}{const} \textcolor{keywordtype}{int} counts[64], \textcolor{keywordtype}{int} max\_buckets) \{
787   \textcolor{keyword}{struct }hist\_bucket bucket[64];
788   \textcolor{keywordtype}{int} buckets = 0;
789   \textcolor{keywordtype}{int} total = 0;
790   \textcolor{keywordtype}{int} scale;
791   \textcolor{keywordtype}{int} i;
792 
793 
794   \textcolor{keywordflow}{for} (i = 0; i < 64; i++) \{
795     \textcolor{keywordflow}{if} (counts[i]) \{
796       bucket[buckets].low = bucket[buckets].high = i;
797       bucket[buckets].count = counts[i];
798       buckets++;
799       total += counts[i];
800     \}
801   \}
802 
803   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nQuantizer Selection:\(\backslash\)n"});
804   scale = merge\_hist\_buckets(bucket, &buckets, max\_buckets);
805   show\_histogram(bucket, buckets, total, scale);
806 \}
807 
808 
809 \textcolor{preprocessor}{#define RATE\_BINS (100)}
810 \textcolor{keyword}{struct }rate\_hist \{
811   int64\_t            *pts;
812   \textcolor{keywordtype}{int}                *sz;
813   \textcolor{keywordtype}{int}                 samples;
814   \textcolor{keywordtype}{int}                 frames;
815   \textcolor{keyword}{struct }hist\_bucket  bucket[RATE\_BINS];
816   \textcolor{keywordtype}{int}                 total;
817 \};
818 
819 
820 \textcolor{keyword}{static} \textcolor{keywordtype}{void} init\_rate\_histogram(\textcolor{keyword}{struct} rate\_hist          *hist,
821                                 \textcolor{keyword}{const} \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *cfg,
822                                 \textcolor{keyword}{const} \hyperlink{structvpx__rational}{vpx\_rational\_t}      *fps) \{
823   \textcolor{keywordtype}{int} i;
824 
825   \textcolor{comment}{/* Determine the number of samples in the buffer. Use the file's framerate}
826 \textcolor{comment}{   * to determine the number of frames in rc\_buf\_sz milliseconds, with an}
827 \textcolor{comment}{   * adjustment (5/4) to account for alt-refs}
828 \textcolor{comment}{   */}
829   hist->samples = cfg->\hyperlink{structvpx__codec__enc__cfg_a61866272bb588cd86d28834f420430f0}{rc\_buf\_sz} * 5 / 4 * fps->\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} / fps->\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} / 1000;
830 
831   \textcolor{comment}{/* prevent division by zero */}
832   \textcolor{keywordflow}{if} (hist->samples == 0)
833     hist->samples = 1;
834 
835   hist->pts = calloc(hist->samples, \textcolor{keyword}{sizeof}(*hist->pts));
836   hist->sz = calloc(hist->samples, \textcolor{keyword}{sizeof}(*hist->sz));
837   \textcolor{keywordflow}{for} (i = 0; i < RATE\_BINS; i++) \{
838     hist->bucket[i].low = INT\_MAX;
839     hist->bucket[i].high = 0;
840     hist->bucket[i].count = 0;
841   \}
842 \}
843 
844 
845 \textcolor{keyword}{static} \textcolor{keywordtype}{void} destroy\_rate\_histogram(\textcolor{keyword}{struct} rate\_hist *hist) \{
846   free(hist->pts);
847   free(hist->sz);
848 \}
849 
850 
851 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_rate\_histogram(\textcolor{keyword}{struct} rate\_hist          *hist,
852                                   \textcolor{keyword}{const} \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *cfg,
853                                   \textcolor{keyword}{const} \hyperlink{structvpx__codec__cx__pkt}{vpx\_codec\_cx\_pkt\_t}  *pkt) \{
854   \textcolor{keywordtype}{int} i, idx;
855   int64\_t now, then, sum\_sz = 0, avg\_bitrate;
856 
857   now = pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.pts * 1000
858         * (uint64\_t)cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} / (uint64\_t)cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.
      \hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den};
859 
860   idx = hist->frames++ % hist->samples;
861   hist->pts[idx] = now;
862   hist->sz[idx] = (int)pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz;
863 
864   if (now < cfg->rc\_buf\_initial\_sz)
865     \textcolor{keywordflow}{return};
866 
867   then = now;
868 
869   \textcolor{comment}{/* Sum the size over the past rc\_buf\_sz ms */}
870   \textcolor{keywordflow}{for} (i = hist->frames; i > 0 && hist->frames - i < hist->samples; i--) \{
871     \textcolor{keywordtype}{int} i\_idx = (i - 1) % hist->samples;
872 
873     then = hist->pts[i\_idx];
874     if (now - then > cfg->\hyperlink{structvpx__codec__enc__cfg_a61866272bb588cd86d28834f420430f0}{rc\_buf\_sz})
875       \textcolor{keywordflow}{break};
876     sum\_sz += hist->sz[i\_idx];
877   \}
878 
879   \textcolor{keywordflow}{if} (now == then)
880     \textcolor{keywordflow}{return};
881 
882   avg\_bitrate = sum\_sz * 8 * 1000 / (now - then);
883   idx = (int)(avg\_bitrate * (RATE\_BINS / 2) / (cfg->\hyperlink{structvpx__codec__enc__cfg_ab8339685175d66710f482706cc9f0aed}{rc\_target\_bitrate} * 1000));
884   \textcolor{keywordflow}{if} (idx < 0)
885     idx = 0;
886   \textcolor{keywordflow}{if} (idx > RATE\_BINS - 1)
887     idx = RATE\_BINS - 1;
888   \textcolor{keywordflow}{if} (hist->bucket[idx].low > avg\_bitrate)
889     hist->bucket[idx].low = (int)avg\_bitrate;
890   \textcolor{keywordflow}{if} (hist->bucket[idx].high < avg\_bitrate)
891     hist->bucket[idx].high = (int)avg\_bitrate;
892   hist->bucket[idx].count++;
893   hist->total++;
894 \}
895 
896 
897 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_rate\_histogram(\textcolor{keyword}{struct} rate\_hist          *hist,
898                                 \textcolor{keyword}{const} \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *cfg,
899                                 \textcolor{keywordtype}{int}                        max\_buckets) \{
900   \textcolor{keywordtype}{int} i, scale;
901   \textcolor{keywordtype}{int} buckets = 0;
902 
903   \textcolor{keywordflow}{for} (i = 0; i < RATE\_BINS; i++) \{
904     \textcolor{keywordflow}{if} (hist->bucket[i].low == INT\_MAX)
905       \textcolor{keywordflow}{continue};
906     hist->bucket[buckets++] = hist->bucket[i];
907   \}
908 
909   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nRate (over %dms window):\(\backslash\)n"}, cfg->\hyperlink{structvpx__codec__enc__cfg_a61866272bb588cd86d28834f420430f0}{rc\_buf\_sz});
910   scale = merge\_hist\_buckets(hist->bucket, &buckets, max\_buckets);
911   show\_histogram(hist->bucket, buckets, hist->total, scale);
912 \}
913 
914 \textcolor{preprocessor}{#define mmin(a, b)  ((a) < (b) ? (a) : (b))}
915 \textcolor{keyword}{static} \textcolor{keywordtype}{void} find\_mismatch(\hyperlink{structvpx__image}{vpx\_image\_t} *img1, \hyperlink{structvpx__image}{vpx\_image\_t} *img2,
916                           \textcolor{keywordtype}{int} yloc[4], \textcolor{keywordtype}{int} uloc[4], \textcolor{keywordtype}{int} vloc[4]) \{
917   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bsize = 64;
918   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bsizey = bsize >> img1->\hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift};
919   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bsizex = bsize >> img1->\hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift};
920   \textcolor{keyword}{const} \textcolor{keywordtype}{int} c\_w = (img1->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w} + img1->\hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift}) >> img1->
      \hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift};
921   \textcolor{keyword}{const} \textcolor{keywordtype}{int} c\_h = (img1->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h} + img1->\hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift}) >> img1->
      \hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift};
922   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} match = 1;
923   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i, j;
924   yloc[0] = yloc[1] = yloc[2] = yloc[3] = -1;
925   \textcolor{keywordflow}{for} (i = 0, match = 1; match && i < img1->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}; i += bsize) \{
926     \textcolor{keywordflow}{for} (j = 0; match && j < img1->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}; j += bsize) \{
927       \textcolor{keywordtype}{int} k, l;
928       \textcolor{keywordtype}{int} si = mmin(i + bsize, img1->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}) - i;
929       \textcolor{keywordtype}{int} sj = mmin(j + bsize, img1->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}) - j;
930       \textcolor{keywordflow}{for} (k = 0; match && k < si; k++)
931         \textcolor{keywordflow}{for} (l = 0; match && l < sj; l++) \{
932           \textcolor{keywordflow}{if} (*(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] +
933                 (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] + j + l) !=
934               *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] +
935                 (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] + j + l)) \{
936             yloc[0] = i + k;
937             yloc[1] = j + l;
938             yloc[2] = *(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] +
939                         (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] + j + l);
940             yloc[3] = *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] +
941                         (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}] + j + l);
942             match = 0;
943             \textcolor{keywordflow}{break};
944           \}
945         \}
946     \}
947   \}
948 
949   uloc[0] = uloc[1] = uloc[2] = uloc[3] = -1;
950   \textcolor{keywordflow}{for} (i = 0, match = 1; match && i < c\_h; i += bsizey) \{
951     \textcolor{keywordflow}{for} (j = 0; match && j < c\_w; j += bsizex) \{
952       \textcolor{keywordtype}{int} k, l;
953       \textcolor{keywordtype}{int} si = mmin(i + bsizey, c\_h - i);
954       \textcolor{keywordtype}{int} sj = mmin(j + bsizex, c\_w - j);
955       \textcolor{keywordflow}{for} (k = 0; match && k < si; k++)
956         \textcolor{keywordflow}{for} (l = 0; match && l < sj; l++) \{
957           \textcolor{keywordflow}{if} (*(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] +
958                 (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] + j + l) !=
959               *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] +
960                 (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] + j + l)) \{
961             uloc[0] = i + k;
962             uloc[1] = j + l;
963             uloc[2] = *(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] +
964                         (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] + j + l);
965             uloc[3] = *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}] +
966                         (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] + j + l);
967             match = 0;
968             \textcolor{keywordflow}{break};
969           \}
970         \}
971     \}
972   \}
973   vloc[0] = vloc[1] = vloc[2] = vloc[3] = -1;
974   \textcolor{keywordflow}{for} (i = 0, match = 1; match && i < c\_h; i += bsizey) \{
975     \textcolor{keywordflow}{for} (j = 0; match && j < c\_w; j += bsizex) \{
976       \textcolor{keywordtype}{int} k, l;
977       \textcolor{keywordtype}{int} si = mmin(i + bsizey, c\_h - i);
978       \textcolor{keywordtype}{int} sj = mmin(j + bsizex, c\_w - j);
979       \textcolor{keywordflow}{for} (k = 0; match && k < si; k++)
980         \textcolor{keywordflow}{for} (l = 0; match && l < sj; l++) \{
981           \textcolor{keywordflow}{if} (*(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] +
982                 (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] + j + l) !=
983               *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] +
984                 (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] + j + l)) \{
985             vloc[0] = i + k;
986             vloc[1] = j + l;
987             vloc[2] = *(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] +
988                         (i + k) * img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] + j + l);
989             vloc[3] = *(img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] +
990                         (i + k) * img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}] + j + l);
991             match = 0;
992             \textcolor{keywordflow}{break};
993           \}
994         \}
995     \}
996   \}
997 \}
998 
999 \textcolor{keyword}{static} \textcolor{keywordtype}{int} compare\_img(\hyperlink{structvpx__image}{vpx\_image\_t} *img1, \hyperlink{structvpx__image}{vpx\_image\_t} *img2)
1000 \{
1001   \textcolor{keyword}{const} \textcolor{keywordtype}{int} c\_w = (img1->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w} + img1->\hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift}) >> img1->
      \hyperlink{structvpx__image_affaf210489dcefebd90b87fd5f12dc0b}{x\_chroma\_shift};
1002   \textcolor{keyword}{const} \textcolor{keywordtype}{int} c\_h = (img1->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h} + img1->\hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift}) >> img1->
      \hyperlink{structvpx__image_a1e3d9b699d46ca32e3916d1ac635a4a2}{y\_chroma\_shift};
1003   \textcolor{keywordtype}{int} match = 1;
1004   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
1005 
1006   match &= (img1->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt} == img2->\hyperlink{structvpx__image_a1d734f8afa9200a21c2d9f6bcf8c04d8}{fmt});
1007   match &= (img1->\hyperlink{structvpx__image_ac7b7d569142f878155b28141653adcd6}{w} == img2->\hyperlink{structvpx__image_ac7b7d569142f878155b28141653adcd6}{w});
1008   match &= (img1->\hyperlink{structvpx__image_a9d1070804dfe08cd5becd68d597fee69}{h} == img2->\hyperlink{structvpx__image_a9d1070804dfe08cd5becd68d597fee69}{h});
1009 
1010   \textcolor{keywordflow}{for} (i = 0; i < img1->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}; i++)
1011     match &= (memcmp(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}]+i*img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_a08171c4636c655e1ab0b76e06219f9e2}{VPX\_PLANE\_Y}],
1012                      img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[VPX\_PLANE\_Y]+i*img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_Y],
1013                      img1->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}) == 0);
1014 
1015   \textcolor{keywordflow}{for} (i = 0; i < c\_h; i++)
1016     match &= (memcmp(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}]+i*img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}],
1017                      img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[VPX\_PLANE\_U]+i*img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_U],
1018                      c\_w) == 0);
1019 
1020   \textcolor{keywordflow}{for} (i = 0; i < c\_h; i++)
1021     match &= (memcmp(img1->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}]+i*img1->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_U],
1022                      img2->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}]+i*img2->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_U],
1023                      c\_w) == 0);
1024 
1025   \textcolor{keywordflow}{return} match;
1026 \}
1027 
1028 
1029 \textcolor{preprocessor}{#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))}
1030 \textcolor{preprocessor}{#define MAX(x,y) ((x)>(y)?(x):(y))}
1031 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER && !CONFIG\_VP9\_ENCODER}
1032 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(vp8\_arg\_ctrl\_map)}
1033 \textcolor{preprocessor}{#elif !CONFIG\_VP8\_ENCODER && CONFIG\_VP9\_ENCODER}
1034 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(vp9\_arg\_ctrl\_map)}
1035 \textcolor{preprocessor}{#else}
1036 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX MAX(NELEMENTS(vp8\_arg\_ctrl\_map), \(\backslash\)}
1037 \textcolor{preprocessor}{                             NELEMENTS(vp9\_arg\_ctrl\_map))}
1038 \textcolor{preprocessor}{#endif}
1039 
1040 \textcolor{comment}{/* Configuration elements common to all streams */}
1041 \textcolor{keyword}{struct }global\_config \{
1042   \textcolor{keyword}{const} \textcolor{keyword}{struct }codec\_item  *codec;
1043   \textcolor{keywordtype}{int}                       passes;
1044   \textcolor{keywordtype}{int}                       pass;
1045   \textcolor{keywordtype}{int}                       usage;
1046   \textcolor{keywordtype}{int}                       deadline;
1047   \textcolor{keywordtype}{int}                       use\_i420;
1048   \textcolor{keywordtype}{int}                       quiet;
1049   \textcolor{keywordtype}{int}                       verbose;
1050   \textcolor{keywordtype}{int}                       limit;
1051   \textcolor{keywordtype}{int}                       skip\_frames;
1052   \textcolor{keywordtype}{int}                       show\_psnr;
1053   \textcolor{keyword}{enum} TestDecodeFatality   test\_decode;
1054   \textcolor{keywordtype}{int}                       have\_framerate;
1055   \textcolor{keyword}{struct }\hyperlink{structvpx__rational}{vpx\_rational}       framerate;
1056   \textcolor{keywordtype}{int}                       out\_part;
1057   \textcolor{keywordtype}{int}                       debug;
1058   \textcolor{keywordtype}{int}                       show\_q\_hist\_buckets;
1059   \textcolor{keywordtype}{int}                       show\_rate\_hist\_buckets;
1060 \};
1061 
1062 
1063 \textcolor{comment}{/* Per-stream configuration */}
1064 \textcolor{keyword}{struct }stream\_config \{
1065   \textcolor{keyword}{struct }\hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg}  cfg;
1066   \textcolor{keyword}{const} \textcolor{keywordtype}{char}               *out\_fn;
1067   \textcolor{keyword}{const} \textcolor{keywordtype}{char}               *stats\_fn;
1068   stereo\_format\_t           stereo\_fmt;
1069   \textcolor{keywordtype}{int}                       arg\_ctrls[ARG\_CTRL\_CNT\_MAX][2];
1070   \textcolor{keywordtype}{int}                       arg\_ctrl\_cnt;
1071   \textcolor{keywordtype}{int}                       write\_webm;
1072   \textcolor{keywordtype}{int}                       have\_kf\_max\_dist;
1073 \};
1074 
1075 
1076 \textcolor{keyword}{struct }stream\_state \{
1077   \textcolor{keywordtype}{int}                       index;
1078   \textcolor{keyword}{struct }stream\_state      *next;
1079   \textcolor{keyword}{struct }stream\_config      config;
1080   FILE                     *file;
1081   \textcolor{keyword}{struct }rate\_hist          rate\_hist;
1082   \textcolor{keyword}{struct }EbmlGlobal         ebml;
1083   uint32\_t                  hash;
1084   uint64\_t                  psnr\_sse\_total;
1085   uint64\_t                  psnr\_samples\_total;
1086   \textcolor{keywordtype}{double}                    psnr\_totals[4];
1087   \textcolor{keywordtype}{int}                       psnr\_count;
1088   \textcolor{keywordtype}{int}                       counts[64];
1089   \hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t}           encoder;
1090   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}              frames\_out;
1091   uint64\_t                  cx\_time;
1092   \textcolor{keywordtype}{size\_t}                    nbytes;
1093   stats\_io\_t                stats;
1094   \textcolor{keyword}{struct }\hyperlink{structvpx__image}{vpx\_image}         *img;
1095   \hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t}           decoder;
1096   \textcolor{keywordtype}{int}                       mismatch\_seen;
1097 \};
1098 
1099 
1100 \textcolor{keywordtype}{void} validate\_positive\_rational(\textcolor{keyword}{const} \textcolor{keywordtype}{char}          *msg,
1101                                 \textcolor{keyword}{struct} \hyperlink{structvpx__rational}{vpx\_rational} *rat) \{
1102   \textcolor{keywordflow}{if} (rat->\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} < 0) \{
1103     rat->\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} *= -1;
1104     rat->\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} *= -1;
1105   \}
1106 
1107   \textcolor{keywordflow}{if} (rat->\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} < 0)
1108     die(\textcolor{stringliteral}{"Error: %s must be positive\(\backslash\)n"}, msg);
1109 
1110   \textcolor{keywordflow}{if} (!rat->\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den})
1111     die(\textcolor{stringliteral}{"Error: %s has zero denominator\(\backslash\)n"}, msg);
1112 \}
1113 
1114 
1115 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_global\_config(\textcolor{keyword}{struct} global\_config *global, \textcolor{keywordtype}{char} **argv) \{
1116   \textcolor{keywordtype}{char}       **argi, **argj;
1117   \textcolor{keyword}{struct }arg   arg;
1118 
1119   \textcolor{comment}{/* Initialize default parameters */}
1120   memset(global, 0, \textcolor{keyword}{sizeof}(*global));
1121   global->codec = codecs;
1122   global->passes = 0;
1123   global->use\_i420 = 1;
1124   \textcolor{comment}{/* Assign default deadline to good quality */}
1125   global->deadline = \hyperlink{group__encoder_ga5d00a9f9e10b9f49ca91e72c1f01c9fd}{VPX\_DL\_GOOD\_QUALITY};
1126 
1127   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1128     arg.argv\_step = 1;
1129 
1130     \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
1131       \textcolor{keywordtype}{int} j, k = -1;
1132 
1133       \textcolor{keywordflow}{for} (j = 0; j < \textcolor{keyword}{sizeof}(codecs) / \textcolor{keyword}{sizeof}(codecs[0]); j++)
1134         \textcolor{keywordflow}{if} (!strcmp(codecs[j].name, arg.val))
1135           k = j;
1136 
1137       \textcolor{keywordflow}{if} (k >= 0)
1138         global->codec = codecs + k;
1139       \textcolor{keywordflow}{else}
1140         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"},
1141             arg.val);
1142 
1143     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &passes, argi)) \{
1144       global->passes = arg\_parse\_uint(&arg);
1145 
1146       \textcolor{keywordflow}{if} (global->passes < 1 || global->passes > 2)
1147         die(\textcolor{stringliteral}{"Error: Invalid number of passes (%d)\(\backslash\)n"}, global->passes);
1148     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pass\_arg, argi)) \{
1149       global->pass = arg\_parse\_uint(&arg);
1150 
1151       \textcolor{keywordflow}{if} (global->pass < 1 || global->pass > 2)
1152         die(\textcolor{stringliteral}{"Error: Invalid pass selected (%d)\(\backslash\)n"},
1153             global->pass);
1154     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &usage, argi))
1155       global->usage = arg\_parse\_uint(&arg);
1156     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &deadline, argi))
1157       global->deadline = arg\_parse\_uint(&arg);
1158     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &best\_dl, argi))
1159       global->deadline = \hyperlink{group__encoder_gab350573bea112f2fdf8e5677db3ac0da}{VPX\_DL\_BEST\_QUALITY};
1160     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &good\_dl, argi))
1161       global->deadline = \hyperlink{group__encoder_ga5d00a9f9e10b9f49ca91e72c1f01c9fd}{VPX\_DL\_GOOD\_QUALITY};
1162     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rt\_dl, argi))
1163       global->deadline = \hyperlink{group__encoder_ga04253cc9ec1146d72fa8bb86bcf32144}{VPX\_DL\_REALTIME};
1164     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi))
1165       global->use\_i420 = 0;
1166     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi))
1167       global->use\_i420 = 1;
1168     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quietarg, argi))
1169       global->quiet = 1;
1170     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
1171       global->verbose = 1;
1172     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limit, argi))
1173       global->limit = arg\_parse\_uint(&arg);
1174     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip, argi))
1175       global->skip\_frames = arg\_parse\_uint(&arg);
1176     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &psnrarg, argi))
1177       global->show\_psnr = 1;
1178     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &recontest, argi))
1179       global->test\_decode = arg\_parse\_enum\_or\_int(&arg);
1180     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framerate, argi)) \{
1181       global->framerate = arg\_parse\_rational(&arg);
1182       validate\_positive\_rational(arg.name, &global->framerate);
1183       global->have\_framerate = 1;
1184     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &out\_part, argi))
1185       global->out\_part = 1;
1186     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &debugmode, argi))
1187       global->debug = 1;
1188     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &q\_hist\_n, argi))
1189       global->show\_q\_hist\_buckets = arg\_parse\_uint(&arg);
1190     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rate\_hist\_n, argi))
1191       global->show\_rate\_hist\_buckets = arg\_parse\_uint(&arg);
1192     \textcolor{keywordflow}{else}
1193       argj++;
1194   \}
1195 
1196   \textcolor{comment}{/* Validate global config */}
1197   \textcolor{keywordflow}{if} (global->passes == 0) \{
1198 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER}
1199     \textcolor{comment}{// Make default VP9 passes = 2 until there is a better quality 1-pass}
1200     \textcolor{comment}{// encoder}
1201     global->passes = (global->codec->iface == vpx\_codec\_vp9\_cx ? 2 : 1);
1202 \textcolor{preprocessor}{#else}
1203     global->passes = 1;
1204 \textcolor{preprocessor}{#endif}
1205   \}
1206 
1207   \textcolor{keywordflow}{if} (global->pass) \{
1208     \textcolor{comment}{/* DWIM: Assume the user meant passes=2 if pass=2 is specified */}
1209     \textcolor{keywordflow}{if} (global->pass > global->passes) \{
1210       warn(\textcolor{stringliteral}{"Assuming --pass=%d implies --passes=%d\(\backslash\)n"},
1211            global->pass, global->pass);
1212       global->passes = global->pass;
1213     \}
1214   \}
1215 \}
1216 
1217 
1218 \textcolor{keywordtype}{void} open\_input\_file(\textcolor{keyword}{struct} input\_state *input) \{
1219   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc;
1220 
1221   \textcolor{comment}{/* Parse certain options from the input file, if possible */}
1222   input->file = strcmp(input->fn, \textcolor{stringliteral}{"-"}) ? fopen(input->fn, \textcolor{stringliteral}{"rb"})
1223                 : set\_binary\_mode(stdin);
1224 
1225   \textcolor{keywordflow}{if} (!input->file)
1226     fatal(\textcolor{stringliteral}{"Failed to open input file"});
1227 
1228   \textcolor{keywordflow}{if} (!fseeko(input->file, 0, SEEK\_END)) \{
1229     \textcolor{comment}{/* Input file is seekable. Figure out how long it is, so we can get}
1230 \textcolor{comment}{     * progress info.}
1231 \textcolor{comment}{     */}
1232     input->length = ftello(input->file);
1233     rewind(input->file);
1234   \}
1235 
1236   \textcolor{comment}{/* For RAW input sources, these bytes will applied on the first frame}
1237 \textcolor{comment}{   *  in read\_frame().}
1238 \textcolor{comment}{   */}
1239   input->detect.buf\_read = fread(input->detect.buf, 1, 4, input->file);
1240   input->detect.position = 0;
1241 
1242   \textcolor{keywordflow}{if} (input->detect.buf\_read == 4
1243       && file\_is\_y4m(input->file, &input->y4m, input->detect.buf)) \{
1244     \textcolor{keywordflow}{if} (y4m\_input\_open(&input->y4m, input->file, input->detect.buf, 4,
1245                        input->only\_i420) >= 0) \{
1246       input->file\_type = FILE\_TYPE\_Y4M;
1247       input->w = input->y4m.pic\_w;
1248       input->h = input->y4m.pic\_h;
1249       input->framerate.num = input->y4m.fps\_n;
1250       input->framerate.den = input->y4m.fps\_d;
1251       input->use\_i420 = 0;
1252     \} \textcolor{keywordflow}{else}
1253       fatal(\textcolor{stringliteral}{"Unsupported Y4M stream."});
1254   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && file\_is\_ivf(input, &fourcc)) \{
1255     fatal(\textcolor{stringliteral}{"IVF is not supported as input."});
1256   \} \textcolor{keywordflow}{else} \{
1257     input->file\_type = FILE\_TYPE\_RAW;
1258   \}
1259 \}
1260 
1261 
1262 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_input\_file(\textcolor{keyword}{struct} input\_state *input) \{
1263   fclose(input->file);
1264   \textcolor{keywordflow}{if} (input->file\_type == FILE\_TYPE\_Y4M)
1265     y4m\_input\_close(&input->y4m);
1266 \}
1267 
1268 \textcolor{keyword}{static} \textcolor{keyword}{struct }stream\_state *new\_stream(\textcolor{keyword}{struct} global\_config *global,
1269                                        \textcolor{keyword}{struct} stream\_state *prev) \{
1270   \textcolor{keyword}{struct }stream\_state *stream;
1271 
1272   stream = calloc(1, \textcolor{keyword}{sizeof}(*stream));
1273   \textcolor{keywordflow}{if} (!stream)
1274     fatal(\textcolor{stringliteral}{"Failed to allocate new stream."});
1275   \textcolor{keywordflow}{if} (prev) \{
1276     memcpy(stream, prev, \textcolor{keyword}{sizeof}(*stream));
1277     stream->index++;
1278     prev->next = stream;
1279   \} \textcolor{keywordflow}{else} \{
1280     \hyperlink{group__codec_gada1084710837ad363b92f2379dd2b8d2}{vpx\_codec\_err\_t}  res;
1281 
1282     \textcolor{comment}{/* Populate encoder configuration */}
1283     res = \hyperlink{group__encoder_ga9ab8c79623312e9c5d5405d66a788f59}{vpx\_codec\_enc\_config\_default}(global->codec->iface(),
1284                                        &stream->config.cfg,
1285                                        global->usage);
1286     \textcolor{keywordflow}{if} (res)
1287       fatal(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_gaaddf5c1f609ef18c7c8800d102fcefa6}{vpx\_codec\_err\_to\_string}(res));
1288 
1289     \textcolor{comment}{/* Change the default timebase to a high enough value so that the}
1290 \textcolor{comment}{     * encoder will always create strictly increasing timestamps.}
1291 \textcolor{comment}{     */}
1292     stream->config.cfg.g\_timebase.den = 1000;
1293 
1294     \textcolor{comment}{/* Never use the library's default resolution, require it be parsed}
1295 \textcolor{comment}{     * from the file or set on the command line.}
1296 \textcolor{comment}{     */}
1297     stream->config.cfg.g\_w = 0;
1298     stream->config.cfg.g\_h = 0;
1299 
1300     \textcolor{comment}{/* Initialize remaining stream parameters */}
1301     stream->config.stereo\_fmt = STEREO\_FORMAT\_MONO;
1302     stream->config.write\_webm = 1;
1303     stream->ebml.last\_pts\_ms = -1;
1304 
1305     \textcolor{comment}{/* Allows removal of the application version from the EBML tags */}
1306     stream->ebml.debug = global->debug;
1307   \}
1308 
1309   \textcolor{comment}{/* Output files must be specified for each stream */}
1310   stream->config.out\_fn = NULL;
1311 
1312   stream->next = NULL;
1313   \textcolor{keywordflow}{return} stream;
1314 \}
1315 
1316 
1317 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_stream\_params(\textcolor{keyword}{struct} global\_config *global,
1318                                \textcolor{keyword}{struct} stream\_state  *stream,
1319                                \textcolor{keywordtype}{char} **argv) \{
1320   \textcolor{keywordtype}{char}                   **argi, **argj;
1321   \textcolor{keyword}{struct }arg               arg;
1322   \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t **ctrl\_args = no\_args;
1323   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int}        *ctrl\_args\_map = NULL;
1324   \textcolor{keyword}{struct }stream\_config    *config = &stream->config;
1325   \textcolor{keywordtype}{int}                      eos\_mark\_found = 0;
1326 
1327   \textcolor{comment}{/* Handle codec specific options */}
1328   \textcolor{keywordflow}{if} (0) \{
1329 \textcolor{preprocessor}{#if CONFIG\_VP8\_ENCODER}
1330   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (global->codec->iface == vpx\_codec\_vp8\_cx) \{
1331     ctrl\_args = vp8\_args;
1332     ctrl\_args\_map = vp8\_arg\_ctrl\_map;
1333 \textcolor{preprocessor}{#endif}
1334 \textcolor{preprocessor}{#if CONFIG\_VP9\_ENCODER}
1335   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (global->codec->iface == vpx\_codec\_vp9\_cx) \{
1336     ctrl\_args = vp9\_args;
1337     ctrl\_args\_map = vp9\_arg\_ctrl\_map;
1338 \textcolor{preprocessor}{#endif}
1339   \}
1340 
1341   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1342     arg.argv\_step = 1;
1343 
1344     \textcolor{comment}{/* Once we've found an end-of-stream marker (--) we want to continue}
1345 \textcolor{comment}{     * shifting arguments but not consuming them.}
1346 \textcolor{comment}{     */}
1347     \textcolor{keywordflow}{if} (eos\_mark\_found) \{
1348       argj++;
1349       \textcolor{keywordflow}{continue};
1350     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(*argj, \textcolor{stringliteral}{"--"})) \{
1351       eos\_mark\_found = 1;
1352       \textcolor{keywordflow}{continue};
1353     \}
1354 
1355     \textcolor{keywordflow}{if} (0);
1356     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi))
1357       config->out\_fn = arg.val;
1358     \textcolor{keywordflow}{else} if (arg\_match(&arg, &fpf\_name, argi))
1359       config->stats\_fn = arg.val;
1360     \textcolor{keywordflow}{else} if (arg\_match(&arg, &use\_ivf, argi))
1361       config->write\_webm = 0;
1362     \textcolor{keywordflow}{else} if (arg\_match(&arg, &threads, argi))
1363       config->cfg.g\_threads = arg\_parse\_uint(&arg);
1364     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &profile, argi))
1365       config->cfg.g\_profile = arg\_parse\_uint(&arg);
1366     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width, argi))
1367       config->cfg.g\_w = arg\_parse\_uint(&arg);
1368     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height, argi))
1369       config->cfg.g\_h = arg\_parse\_uint(&arg);
1370     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &stereo\_mode, argi))
1371       config->stereo\_fmt = arg\_parse\_enum\_or\_int(&arg);
1372     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase, argi)) \{
1373       config->cfg.g\_timebase = arg\_parse\_rational(&arg);
1374       validate\_positive\_rational(arg.name, &config->cfg.g\_timebase);
1375     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &error\_resilient, argi))
1376       config->cfg.g\_error\_resilient = arg\_parse\_uint(&arg);
1377     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &lag\_in\_frames, argi))
1378       config->cfg.g\_lag\_in\_frames = arg\_parse\_uint(&arg);
1379     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dropframe\_thresh, argi))
1380       config->cfg.rc\_dropframe\_thresh = arg\_parse\_uint(&arg);
1381     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_allowed, argi))
1382       config->cfg.rc\_resize\_allowed = arg\_parse\_uint(&arg);
1383     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_up\_thresh, argi))
1384       config->cfg.rc\_resize\_up\_thresh = arg\_parse\_uint(&arg);
1385     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_down\_thresh, argi))
1386       config->cfg.rc\_resize\_down\_thresh = arg\_parse\_uint(&arg);
1387     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &end\_usage, argi))
1388       config->cfg.rc\_end\_usage = arg\_parse\_enum\_or\_int(&arg);
1389     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &target\_bitrate, argi))
1390       config->cfg.rc\_target\_bitrate = arg\_parse\_uint(&arg);
1391     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &min\_quantizer, argi))
1392       config->cfg.rc\_min\_quantizer = arg\_parse\_uint(&arg);
1393     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &max\_quantizer, argi))
1394       config->cfg.rc\_max\_quantizer = arg\_parse\_uint(&arg);
1395     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &undershoot\_pct, argi))
1396       config->cfg.rc\_undershoot\_pct = arg\_parse\_uint(&arg);
1397     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &overshoot\_pct, argi))
1398       config->cfg.rc\_overshoot\_pct = arg\_parse\_uint(&arg);
1399     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_sz, argi))
1400       config->cfg.rc\_buf\_sz = arg\_parse\_uint(&arg);
1401     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_initial\_sz, argi))
1402       config->cfg.rc\_buf\_initial\_sz = arg\_parse\_uint(&arg);
1403     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_optimal\_sz, argi))
1404       config->cfg.rc\_buf\_optimal\_sz = arg\_parse\_uint(&arg);
1405     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bias\_pct, argi)) \{
1406       config->cfg.rc\_2pass\_vbr\_bias\_pct = arg\_parse\_uint(&arg);
1407 
1408       \textcolor{keywordflow}{if} (global->passes < 2)
1409         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1410     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &minsection\_pct, argi)) \{
1411       config->cfg.rc\_2pass\_vbr\_minsection\_pct = arg\_parse\_uint(&arg);
1412 
1413       \textcolor{keywordflow}{if} (global->passes < 2)
1414         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1415     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &maxsection\_pct, argi)) \{
1416       config->cfg.rc\_2pass\_vbr\_maxsection\_pct = arg\_parse\_uint(&arg);
1417 
1418       \textcolor{keywordflow}{if} (global->passes < 2)
1419         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1420     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_min\_dist, argi))
1421       config->cfg.kf\_min\_dist = arg\_parse\_uint(&arg);
1422     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_max\_dist, argi)) \{
1423       config->cfg.kf\_max\_dist = arg\_parse\_uint(&arg);
1424       config->have\_kf\_max\_dist = 1;
1425     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_disabled, argi))
1426       config->cfg.kf\_mode = \hyperlink{group__encoder_gga9f461802aa4db35c04a8b23837987f40a56513f60cbf3434ca0092173005d0ab2}{VPX\_KF\_DISABLED};
1427     \textcolor{keywordflow}{else} \{
1428       \textcolor{keywordtype}{int} i, match = 0;
1429 
1430       \textcolor{keywordflow}{for} (i = 0; ctrl\_args[i]; i++) \{
1431         \textcolor{keywordflow}{if} (arg\_match(&arg, ctrl\_args[i], argi)) \{
1432           \textcolor{keywordtype}{int} j;
1433           match = 1;
1434 
1435           \textcolor{comment}{/* Point either to the next free element or the first}
1436 \textcolor{comment}{          * instance of this control.}
1437 \textcolor{comment}{          */}
1438           \textcolor{keywordflow}{for} (j = 0; j < config->arg\_ctrl\_cnt; j++)
1439             \textcolor{keywordflow}{if} (config->arg\_ctrls[j][0] == ctrl\_args\_map[i])
1440               \textcolor{keywordflow}{break};
1441 
1442           \textcolor{comment}{/* Update/insert */}
1443           assert(j < ARG\_CTRL\_CNT\_MAX);
1444           \textcolor{keywordflow}{if} (j < ARG\_CTRL\_CNT\_MAX) \{
1445             config->arg\_ctrls[j][0] = ctrl\_args\_map[i];
1446             config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(&arg);
1447             \textcolor{keywordflow}{if} (j == config->arg\_ctrl\_cnt)
1448               config->arg\_ctrl\_cnt++;
1449           \}
1450 
1451         \}
1452       \}
1453 
1454       \textcolor{keywordflow}{if} (!match)
1455         argj++;
1456     \}
1457   \}
1458 
1459   \textcolor{keywordflow}{return} eos\_mark\_found;
1460 \}
1461 
1462 
1463 \textcolor{preprocessor}{#define FOREACH\_STREAM(func)\(\backslash\)}
1464 \textcolor{preprocessor}{  do\(\backslash\)}
1465 \textcolor{preprocessor}{  \{\(\backslash\)}
1466 \textcolor{preprocessor}{    struct stream\_state  *stream;\(\backslash\)}
1467 \textcolor{preprocessor}{    \(\backslash\)}
1468 \textcolor{preprocessor}{    for(stream = streams; stream; stream = stream->next)\(\backslash\)}
1469 \textcolor{preprocessor}{      func;\(\backslash\)}
1470 \textcolor{preprocessor}{  \}while(0)}
1471 
1472 
1473 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_stream\_config(\textcolor{keyword}{struct} stream\_state *stream) \{
1474   \textcolor{keyword}{struct }stream\_state *streami;
1475 
1476   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w || !stream->config.cfg.g\_h)
1477     fatal(\textcolor{stringliteral}{"Stream %d: Specify stream dimensions with --width (-w) "}
1478           \textcolor{stringliteral}{" and --height (-h)"}, stream->index);
1479 
1480   \textcolor{keywordflow}{for} (streami = stream; streami; streami = streami->next) \{
1481     \textcolor{comment}{/* All streams require output files */}
1482     \textcolor{keywordflow}{if} (!streami->config.out\_fn)
1483       fatal(\textcolor{stringliteral}{"Stream %d: Output file is required (specify with -o)"},
1484             streami->index);
1485 
1486     \textcolor{comment}{/* Check for two streams outputting to the same file */}
1487     \textcolor{keywordflow}{if} (streami != stream) \{
1488       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.out\_fn;
1489       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.out\_fn;
1490       \textcolor{keywordflow}{if} (!strcmp(a, b) && strcmp(a, \textcolor{stringliteral}{"/dev/null"}) && strcmp(a, \textcolor{stringliteral}{":nul"}))
1491         fatal(\textcolor{stringliteral}{"Stream %d: duplicate output file (from stream %d)"},
1492               streami->index, stream->index);
1493     \}
1494 
1495     \textcolor{comment}{/* Check for two streams sharing a stats file. */}
1496     \textcolor{keywordflow}{if} (streami != stream) \{
1497       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.stats\_fn;
1498       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.stats\_fn;
1499       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1500         fatal(\textcolor{stringliteral}{"Stream %d: duplicate stats file (from stream %d)"},
1501               streami->index, stream->index);
1502     \}
1503   \}
1504 \}
1505 
1506 
1507 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_stream\_dimensions(\textcolor{keyword}{struct} stream\_state *stream,
1508                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w,
1509                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{
1510   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w) \{
1511     \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h)
1512       stream->config.cfg.g\_w = w;
1513     \textcolor{keywordflow}{else}
1514       stream->config.cfg.g\_w = w * stream->config.cfg.g\_h / h;
1515   \}
1516   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h) \{
1517     stream->config.cfg.g\_h = h * stream->config.cfg.g\_w / w;
1518   \}
1519 \}
1520 
1521 
1522 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_default\_kf\_interval(\textcolor{keyword}{struct} stream\_state  *stream,
1523                                     \textcolor{keyword}{struct} global\_config *global) \{
1524   \textcolor{comment}{/* Use a max keyframe interval of 5 seconds, if none was}
1525 \textcolor{comment}{   * specified on the command line.}
1526 \textcolor{comment}{   */}
1527   \textcolor{keywordflow}{if} (!stream->config.have\_kf\_max\_dist) \{
1528     \textcolor{keywordtype}{double} framerate = (double)global->framerate.num / global->framerate.den;
1529     if (framerate > 0.0)
1530       stream->config.cfg.kf\_max\_dist = (\textcolor{keywordtype}{unsigned} int)(5.0 * framerate);
1531   \}
1532 \}
1533 
1534 
1535 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_stream\_config(\textcolor{keyword}{struct} stream\_state  *stream,
1536                                \textcolor{keyword}{struct} global\_config *global,
1537                                \textcolor{keyword}{struct} input\_state   *input) \{
1538 
1539 \textcolor{preprocessor}{#define SHOW(field) \(\backslash\)}
1540 \textcolor{preprocessor}{  fprintf(stderr, "    %-28s = %d\(\backslash\)n", #field, stream->config.cfg.field)}
1541 
1542   \textcolor{keywordflow}{if} (stream->index == 0) \{
1543     fprintf(stderr, \textcolor{stringliteral}{"Codec: %s\(\backslash\)n"},
1544             \hyperlink{group__codec_ga9eee39f450d8cdcf5aba0e2bda6e5aa8}{vpx\_codec\_iface\_name}(global->codec->iface()));
1545     fprintf(stderr, \textcolor{stringliteral}{"Source file: %s Format: %s\(\backslash\)n"}, input->fn,
1546             input->use\_i420 ? \textcolor{stringliteral}{"I420"} : \textcolor{stringliteral}{"YV12"});
1547   \}
1548   \textcolor{keywordflow}{if} (stream->next || stream->index)
1549     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream Index: %d\(\backslash\)n"}, stream->index);
1550   fprintf(stderr, \textcolor{stringliteral}{"Destination file: %s\(\backslash\)n"}, stream->config.out\_fn);
1551   fprintf(stderr, \textcolor{stringliteral}{"Encoder parameters:\(\backslash\)n"});
1552 
1553   SHOW(g\_usage);
1554   SHOW(g\_threads);
1555   SHOW(g\_profile);
1556   SHOW(g\_w);
1557   SHOW(g\_h);
1558   SHOW(g\_timebase.num);
1559   SHOW(g\_timebase.den);
1560   SHOW(g\_error\_resilient);
1561   SHOW(g\_pass);
1562   SHOW(g\_lag\_in\_frames);
1563   SHOW(rc\_dropframe\_thresh);
1564   SHOW(rc\_resize\_allowed);
1565   SHOW(rc\_resize\_up\_thresh);
1566   SHOW(rc\_resize\_down\_thresh);
1567   SHOW(rc\_end\_usage);
1568   SHOW(rc\_target\_bitrate);
1569   SHOW(rc\_min\_quantizer);
1570   SHOW(rc\_max\_quantizer);
1571   SHOW(rc\_undershoot\_pct);
1572   SHOW(rc\_overshoot\_pct);
1573   SHOW(rc\_buf\_sz);
1574   SHOW(rc\_buf\_initial\_sz);
1575   SHOW(rc\_buf\_optimal\_sz);
1576   SHOW(rc\_2pass\_vbr\_bias\_pct);
1577   SHOW(rc\_2pass\_vbr\_minsection\_pct);
1578   SHOW(rc\_2pass\_vbr\_maxsection\_pct);
1579   SHOW(kf\_mode);
1580   SHOW(kf\_min\_dist);
1581   SHOW(kf\_max\_dist);
1582 \}
1583 
1584 
1585 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1586                              \textcolor{keyword}{struct} global\_config *global) \{
1587   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fn = stream->config.out\_fn;
1588 
1589   stream->file = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"wb"}) : set\_binary\_mode(stdout);
1590 
1591   \textcolor{keywordflow}{if} (!stream->file)
1592     fatal(\textcolor{stringliteral}{"Failed to open output file"});
1593 
1594   \textcolor{keywordflow}{if} (stream->config.write\_webm && fseek(stream->file, 0, SEEK\_CUR))
1595     fatal(\textcolor{stringliteral}{"WebM output to pipes not supported."});
1596 
1597   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1598     stream->ebml.stream = stream->file;
1599     write\_webm\_file\_header(&stream->ebml, &stream->config.cfg,
1600                            &global->framerate,
1601                            stream->config.stereo\_fmt,
1602                            global->codec->fourcc);
1603   \} \textcolor{keywordflow}{else}
1604     write\_ivf\_file\_header(stream->file, &stream->config.cfg,
1605                           global->codec->fourcc, 0);
1606 \}
1607 
1608 
1609 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1610                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}         fourcc) \{
1611   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1612     write\_webm\_file\_footer(&stream->ebml, stream->hash);
1613     free(stream->ebml.cue\_list);
1614     stream->ebml.cue\_list = NULL;
1615   \} \textcolor{keywordflow}{else} \{
1616     \textcolor{keywordflow}{if} (!fseek(stream->file, 0, SEEK\_SET))
1617       write\_ivf\_file\_header(stream->file, &stream->config.cfg,
1618                             fourcc,
1619                             stream->frames\_out);
1620   \}
1621 
1622   fclose(stream->file);
1623 \}
1624 
1625 
1626 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setup\_pass(\textcolor{keyword}{struct} stream\_state  *stream,
1627                        \textcolor{keyword}{struct} global\_config *global,
1628                        \textcolor{keywordtype}{int}                   pass) \{
1629   \textcolor{keywordflow}{if} (stream->config.stats\_fn) \{
1630     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->stats, stream->config.stats\_fn,
1631                          pass))
1632       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1633   \} \textcolor{keywordflow}{else} \{
1634     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->stats, pass))
1635       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1636   \}
1637 
1638   stream->config.cfg.g\_pass = global->passes == 2
1639                               ? pass ? \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa65da543b956d6a9b1f301ab8cc90d3a7}{VPX\_RC\_LAST\_PASS} : 
      \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493faa0765945345b160905f3b762986dae3b}{VPX\_RC\_FIRST\_PASS}
1640                             : \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa7b6943a41868e8e26a77e9500f139ca1}{VPX\_RC\_ONE\_PASS};
1641   \textcolor{keywordflow}{if} (pass)
1642     stream->config.cfg.rc\_twopass\_stats\_in = stats\_get(&stream->stats);
1643 
1644   stream->cx\_time = 0;
1645   stream->nbytes = 0;
1646   stream->frames\_out = 0;
1647 \}
1648 
1649 
1650 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initialize\_encoder(\textcolor{keyword}{struct} stream\_state  *stream,
1651                                \textcolor{keyword}{struct} global\_config *global) \{
1652   \textcolor{keywordtype}{int} i;
1653   \textcolor{keywordtype}{int} flags = 0;
1654 
1655   flags |= global->show\_psnr ? \hyperlink{group__encoder_ga57bb9eb1881c7e4bf86580660a5e40a0}{VPX\_CODEC\_USE\_PSNR} : 0;
1656   flags |= global->out\_part ? \hyperlink{group__encoder_gac26cd92b3719953aa0fbb0ff8c1d9c8d}{VPX\_CODEC\_USE\_OUTPUT\_PARTITION} : 0;
1657 
1658   \textcolor{comment}{/* Construct Encoder Context */}
1659   \hyperlink{group__encoder_ga3d490a2a9a6acd7c9ef82a603155f3cf}{vpx\_codec\_enc\_init}(&stream->encoder, global->codec->iface(),
1660                      &stream->config.cfg, flags);
1661   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to initialize encoder"});
1662 
1663   \textcolor{comment}{/* Note that we bypass the vpx\_codec\_control wrapper macro because}
1664 \textcolor{comment}{   * we're being clever to store the control IDs in an array. Real}
1665 \textcolor{comment}{   * applications will want to make use of the enumerations directly}
1666 \textcolor{comment}{   */}
1667   \textcolor{keywordflow}{for} (i = 0; i < stream->config.arg\_ctrl\_cnt; i++) \{
1668     \textcolor{keywordtype}{int} ctrl = stream->config.arg\_ctrls[i][0];
1669     \textcolor{keywordtype}{int} value = stream->config.arg\_ctrls[i][1];
1670     \textcolor{keywordflow}{if} (\hyperlink{group__codec_gaf7849b69cc390b21d889c8c71f69ec14}{vpx\_codec\_control\_}(&stream->encoder, ctrl, value))
1671       fprintf(stderr, \textcolor{stringliteral}{"Error: Tried to set control %d = %d\(\backslash\)n"},
1672               ctrl, value);
1673 
1674     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to control codec"});
1675   \}
1676 
1677 \textcolor{preprocessor}{#if CONFIG\_DECODERS}
1678   \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF) \{
1679     \hyperlink{group__decoder_ga8c2f0b12f1bd4927eb3c68b01eab19d3}{vpx\_codec\_dec\_init}(&stream->decoder, global->codec->dx\_iface(), NULL, 0);
1680   \}
1681 \textcolor{preprocessor}{#endif}
1682 \}
1683 
1684 
1685 \textcolor{keyword}{static} \textcolor{keywordtype}{void} encode\_frame(\textcolor{keyword}{struct} stream\_state  *stream,
1686                          \textcolor{keyword}{struct} global\_config *global,
1687                          \textcolor{keyword}{struct} \hyperlink{structvpx__image}{vpx\_image}     *img,
1688                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}          frames\_in) \{
1689   \hyperlink{group__encoder_ga7e711b0a71c65aef8f0faea8bd57b05f}{vpx\_codec\_pts\_t} frame\_start, next\_frame\_start;
1690   \textcolor{keyword}{struct }\hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1691   \textcolor{keyword}{struct }vpx\_usec\_timer timer;
1692 
1693   frame\_start = (cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} * (int64\_t)(frames\_in - 1)
1694                  * global->framerate.den)
1695                 / cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} / global->framerate.num;
1696   next\_frame\_start = (cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} * (int64\_t)(frames\_in)
1697                       * global->framerate.den)
1698                      / cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} / global->framerate.num;
1699 
1700   \textcolor{comment}{/* Scale if necessary */}
1701   \textcolor{keywordflow}{if} (img && (img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w} != cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} || img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h} != cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h})) \{
1702     \textcolor{keywordflow}{if} (!stream->img)
1703       stream->img = \hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(NULL, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420},
1704                                   cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h}, 16);
1705     I420Scale(img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[VPX\_PLANE\_Y], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_Y],
1706               img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[VPX\_PLANE\_U], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[VPX\_PLANE\_U],
1707               img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}], img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[
      \hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1708               img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}, img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h},
1709               stream->img->planes[VPX\_PLANE\_Y],
1710               stream->img->stride[VPX\_PLANE\_Y],
1711               stream->img->planes[VPX\_PLANE\_U],
1712               stream->img->stride[VPX\_PLANE\_U],
1713               stream->img->planes[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1714               stream->img->stride[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}],
1715               stream->img->d\_w, stream->img->d\_h,
1716               kFilterBox);
1717 
1718     img = stream->img;
1719   \}
1720 
1721   vpx\_usec\_timer\_start(&timer);
1722   \hyperlink{group__encoder_gaf990542e2aeb389f05fae3e9c7803639}{vpx\_codec\_encode}(&stream->encoder, img, frame\_start,
1723                    (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})(next\_frame\_start - frame\_start),
1724                    0, global->deadline);
1725   vpx\_usec\_timer\_mark(&timer);
1726   stream->cx\_time += vpx\_usec\_timer\_elapsed(&timer);
1727   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Stream %d: Failed to encode frame"},
1728                     stream->index);
1729 \}
1730 
1731 
1732 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_quantizer\_histogram(\textcolor{keyword}{struct} stream\_state *stream) \{
1733   \textcolor{keywordflow}{if} (stream->config.cfg.g\_pass != \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493faa0765945345b160905f3b762986dae3b}{VPX\_RC\_FIRST\_PASS}) \{
1734     \textcolor{keywordtype}{int} q;
1735 
1736     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&stream->encoder, 
      \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecad2cfc9712d2eab30b5a59a60d0daaade}{VP8E\_GET\_LAST\_QUANTIZER\_64}, &q);
1737     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to read quantizer"});
1738     stream->counts[q]++;
1739   \}
1740 \}
1741 
1742 
1743 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_cx\_data(\textcolor{keyword}{struct} stream\_state  *stream,
1744                         \textcolor{keyword}{struct} global\_config *global,
1745                         \textcolor{keywordtype}{int}                  *got\_data) \{
1746   \textcolor{keyword}{const} \hyperlink{structvpx__codec__cx__pkt}{vpx\_codec\_cx\_pkt\_t} *pkt;
1747   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1748   \hyperlink{group__codec_ga6ea348f76b1f8a1fe50e14db684146c6}{vpx\_codec\_iter\_t} iter = NULL;
1749 
1750   *got\_data = 0;
1751   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gae81cab25d66cf3bc59f1f75f8a5af720}{vpx\_codec\_get\_cx\_data}(&stream->encoder, &iter))) \{
1752     \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} fsize = 0;
1753     \textcolor{keyword}{static} off\_t ivf\_header\_pos = 0;
1754 
1755     \textcolor{keywordflow}{switch} (pkt->\hyperlink{structvpx__codec__cx__pkt_a41f395b39516343c1329a4a85a0084f2}{kind}) \{
1756       \textcolor{keywordflow}{case} \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a2261aae5594289400e812fb1e6b6b0cc}{VPX\_CODEC\_CX\_FRAME\_PKT}:
1757         \textcolor{keywordflow}{if} (!(pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.flags & \hyperlink{group__encoder_gafb9f7dbf9b8a764c521d8b12c0e6959d}{VPX\_FRAME\_IS\_FRAGMENT})) \{
1758           stream->frames\_out++;
1759         \}
1760         \textcolor{keywordflow}{if} (!global->quiet)
1761           fprintf(stderr, \textcolor{stringliteral}{" %6luF"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz);
1762 
1763         update\_rate\_histogram(&stream->rate\_hist, cfg, pkt);
1764         \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1765           \textcolor{comment}{/* Update the hash */}
1766           \textcolor{keywordflow}{if} (!stream->ebml.debug)
1767             stream->hash = murmur(pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.buf,
1768                                   (\textcolor{keywordtype}{int})pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz,
1769                                   stream->hash);
1770 
1771           write\_webm\_block(&stream->ebml, cfg, pkt);
1772         \} \textcolor{keywordflow}{else} \{
1773           \textcolor{keywordflow}{if} (pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.partition\_id <= 0) \{
1774             ivf\_header\_pos = ftello(stream->file);
1775             fsize = pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz;
1776 
1777             write\_ivf\_frame\_header(stream->file, pkt);
1778           \} \textcolor{keywordflow}{else} \{
1779             fsize += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz;
1780 
1781             \textcolor{keywordflow}{if} (!(pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.flags & \hyperlink{group__encoder_gafb9f7dbf9b8a764c521d8b12c0e6959d}{VPX\_FRAME\_IS\_FRAGMENT})) \{
1782               off\_t currpos = ftello(stream->file);
1783               fseeko(stream->file, ivf\_header\_pos, SEEK\_SET);
1784               write\_ivf\_frame\_size(stream->file, fsize);
1785               fseeko(stream->file, currpos, SEEK\_SET);
1786             \}
1787           \}
1788 
1789           (void) fwrite(pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.buf, 1, pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz,
1790                         stream->file);
1791         \}
1792         stream->nbytes += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_acc7ee91ea9c907aea7c3b953324f7c26}{raw}.\hyperlink{structvpx__fixed__buf_a43d7f8247ed9752f65f0a7639817ae84}{sz};
1793 
1794         *got\_data = 1;
1795 \textcolor{preprocessor}{#if CONFIG\_DECODERS}
1796         \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF && !stream->mismatch\_seen) \{
1797           \hyperlink{group__decoder_ga3441e157a7a69108bca9a069f2ee8e0d}{vpx\_codec\_decode}(&stream->decoder, pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.buf,
1798                            pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz, NULL, 0);
1799           \textcolor{keywordflow}{if} (stream->decoder.err) \{
1800             warn\_or\_exit\_on\_error(&stream->decoder,
1801                                   global->test\_decode == TEST\_DECODE\_FATAL,
1802                                   \textcolor{stringliteral}{"Failed to decode frame %d in stream %d"},
1803                                   stream->frames\_out + 1, stream->index);
1804             stream->mismatch\_seen = stream->frames\_out + 1;
1805           \}
1806         \}
1807 \textcolor{preprocessor}{#endif}
1808         \textcolor{keywordflow}{break};
1809       \textcolor{keywordflow}{case} \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a77cd8b95d9891bcce36117f5f31994fd}{VPX\_CODEC\_STATS\_PKT}:
1810         stream->frames\_out++;
1811         stats\_write(&stream->stats,
1812                     pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a53db8576979fa7335e478eb849b256f1}{twopass\_stats}.\hyperlink{structvpx__fixed__buf_ac93e43ae3fcc1023dca86d37016ae3f0}{buf},
1813                     pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a53db8576979fa7335e478eb849b256f1}{twopass\_stats}.\hyperlink{structvpx__fixed__buf_a43d7f8247ed9752f65f0a7639817ae84}{sz});
1814         stream->nbytes += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_acc7ee91ea9c907aea7c3b953324f7c26}{raw}.\hyperlink{structvpx__fixed__buf_a43d7f8247ed9752f65f0a7639817ae84}{sz};
1815         \textcolor{keywordflow}{break};
1816       \textcolor{keywordflow}{case} \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a11eefa1328e6d22eb7c844645a260628}{VPX\_CODEC\_PSNR\_PKT}:
1817 
1818         \textcolor{keywordflow}{if} (global->show\_psnr) \{
1819           \textcolor{keywordtype}{int} i;
1820 
1821           stream->psnr\_sse\_total += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a63744aeceb50355d6402d55309c151b6}{psnr}.sse[0];
1822           stream->psnr\_samples\_total += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a63744aeceb50355d6402d55309c151b6}{psnr}.samples[0];
1823           \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1824             \textcolor{keywordflow}{if} (!global->quiet)
1825               fprintf(stderr, \textcolor{stringliteral}{"%.3f "}, pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a63744aeceb50355d6402d55309c151b6}{psnr}.psnr[i]);
1826             stream->psnr\_totals[i] += pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a63744aeceb50355d6402d55309c151b6}{psnr}.psnr[i];
1827           \}
1828           stream->psnr\_count++;
1829         \}
1830 
1831         \textcolor{keywordflow}{break};
1832       \textcolor{keywordflow}{default}:
1833         \textcolor{keywordflow}{break};
1834     \}
1835   \}
1836 \}
1837 
1838 
1839 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_psnr(\textcolor{keyword}{struct} stream\_state  *stream) \{
1840   \textcolor{keywordtype}{int} i;
1841   \textcolor{keywordtype}{double} ovpsnr;
1842 
1843   \textcolor{keywordflow}{if} (!stream->psnr\_count)
1844     \textcolor{keywordflow}{return};
1845 
1846   fprintf(stderr, \textcolor{stringliteral}{"Stream %d PSNR (Overall/Avg/Y/U/V)"}, stream->index);
1847   ovpsnr = vp8\_mse2psnr((\textcolor{keywordtype}{double})stream->psnr\_samples\_total, 255.0,
1848                         (\textcolor{keywordtype}{double})stream->psnr\_sse\_total);
1849   fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, ovpsnr);
1850 
1851   \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1852     fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, stream->psnr\_totals[i] / stream->psnr\_count);
1853   \}
1854   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
1855 \}
1856 
1857 
1858 \textcolor{keyword}{static} \textcolor{keywordtype}{float} usec\_to\_fps(uint64\_t usec, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames) \{
1859   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})(usec > 0 ? frames * 1000000.0 / (float)usec : 0);
1860 \}
1861 
1862 
1863 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_decode(\textcolor{keyword}{struct} stream\_state  *stream,
1864                         \textcolor{keyword}{enum} TestDecodeFatality fatal,
1865                         \textcolor{keyword}{const} \textcolor{keyword}{struct} codec\_item *codec) \{
1866   \hyperlink{structvpx__image}{vpx\_image\_t} enc\_img, dec\_img;
1867 
1868   \textcolor{keywordflow}{if} (stream->mismatch\_seen)
1869     \textcolor{keywordflow}{return};
1870 
1871   \textcolor{comment}{/* Get the internal reference frame */}
1872   \textcolor{keywordflow}{if} (codec->fourcc == VP8\_FOURCC) \{
1873     \textcolor{keyword}{struct }\hyperlink{structvpx__ref__frame}{vpx\_ref\_frame} ref\_enc, ref\_dec;
1874     \textcolor{keywordtype}{int} width, height;
1875 
1876     width = (stream->config.cfg.g\_w + 15) & ~15;
1877     height = (stream->config.cfg.g\_h + 15) & ~15;
1878     \hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(&ref\_enc.img, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420}, width, height, 1);
1879     enc\_img = ref\_enc.img;
1880     \hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(&ref\_dec.img, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420}, width, height, 1);
1881     dec\_img = ref\_dec.img;
1882 
1883     ref\_enc.frame\_type = VP8\_LAST\_FRAME;
1884     ref\_dec.frame\_type = VP8\_LAST\_FRAME;
1885     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&stream->encoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599a5375b3ea3a4867d50daee6f5971c7470}{VP8\_COPY\_REFERENCE}, &ref\_enc);
1886     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&stream->decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599a5375b3ea3a4867d50daee6f5971c7470}{VP8\_COPY\_REFERENCE}, &ref\_dec);
1887   \} \textcolor{keywordflow}{else} \{
1888     \textcolor{keyword}{struct }\hyperlink{structvp9__ref__frame}{vp9\_ref\_frame} ref;
1889 
1890     ref.\hyperlink{structvp9__ref__frame_a26e0d119a61c29b72c6ccb91748b6b82}{idx} = 0;
1891     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&stream->encoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599a91e44472b21c720a9a7d087c7226d083}{VP9\_GET\_REFERENCE}, &ref);
1892     enc\_img = ref.img;
1893     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&stream->decoder, \hyperlink{group__vp8_gga8cadbc8e0af3da96ef7a2dbd4ed06599a91e44472b21c720a9a7d087c7226d083}{VP9\_GET\_REFERENCE}, &ref);
1894     dec\_img = ref.img;
1895   \}
1896   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
1897   ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
1898 
1899   \textcolor{keywordflow}{if} (!compare\_img(&enc\_img, &dec\_img)) \{
1900     \textcolor{keywordtype}{int} y[4], u[4], v[4];
1901     find\_mismatch(&enc\_img, &dec\_img, y, u, v);
1902     stream->decoder.err = 1;
1903     warn\_or\_exit\_on\_error(&stream->decoder, fatal == TEST\_DECODE\_FATAL,
1904                           \textcolor{stringliteral}{"Stream %d: Encode/decode mismatch on frame %d at"}
1905                           \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
1906                           \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
1907                           \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
1908                           stream->index, stream->frames\_out,
1909                           y[0], y[1], y[2], y[3],
1910                           u[0], u[1], u[2], u[3],
1911                           v[0], v[1], v[2], v[3]);
1912     stream->mismatch\_seen = stream->frames\_out;
1913   \}
1914 
1915   \hyperlink{vpx__image_8h_af47ebaf286812d037425d41990d48a17}{vpx\_img\_free}(&enc\_img);
1916   \hyperlink{vpx__image_8h_af47ebaf286812d037425d41990d48a17}{vpx\_img\_free}(&dec\_img);
1917 \}
1918 
1919 
1920 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_time(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *label, int64\_t etl) \{
1921   \textcolor{keywordtype}{int} hours, mins, secs;
1922 
1923   \textcolor{keywordflow}{if} (etl >= 0) \{
1924     hours = etl / 3600;
1925     etl -= hours * 3600;
1926     mins = etl / 60;
1927     etl -= mins * 60;
1928     secs = etl;
1929 
1930     fprintf(stderr, \textcolor{stringliteral}{"[%3s %2d:%02d:%02d] "},
1931             label, hours, mins, secs);
1932   \} \textcolor{keywordflow}{else} \{
1933     fprintf(stderr, \textcolor{stringliteral}{"[%3s  unknown] "}, label);
1934   \}
1935 \}
1936 
1937 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1938   \textcolor{keywordtype}{int}                    pass;
1939   \hyperlink{structvpx__image}{vpx\_image\_t}            raw;
1940   \textcolor{keywordtype}{int}                    frame\_avail, got\_data;
1941 
1942   \textcolor{keyword}{struct }input\_state       input = \{0\};
1943   \textcolor{keyword}{struct }global\_config     global;
1944   \textcolor{keyword}{struct }stream\_state     *streams = NULL;
1945   \textcolor{keywordtype}{char}                   **argv, **argi;
1946   uint64\_t                 cx\_time = 0;
1947   \textcolor{keywordtype}{int}                      stream\_cnt = 0;
1948   \textcolor{keywordtype}{int}                      res = 0;
1949 
1950   exec\_name = argv\_[0];
1951 
1952   \textcolor{keywordflow}{if} (argc < 3)
1953     usage\_exit();
1954 
1955   \textcolor{comment}{/* Setup default input stream settings */}
1956   input.framerate.num = 30;
1957   input.framerate.den = 1;
1958   input.use\_i420 = 1;
1959   input.only\_i420 = 1;
1960 
1961   \textcolor{comment}{/* First parse the global configuration values, because we want to apply}
1962 \textcolor{comment}{   * other parameters on top of the default configuration provided by the}
1963 \textcolor{comment}{   * codec.}
1964 \textcolor{comment}{   */}
1965   argv = argv\_dup(argc - 1, argv\_ + 1);
1966   parse\_global\_config(&global, argv);
1967 
1968   \{
1969     \textcolor{comment}{/* Now parse each stream's parameters. Using a local scope here}
1970 \textcolor{comment}{     * due to the use of 'stream' as loop variable in FOREACH\_STREAM}
1971 \textcolor{comment}{     * loops}
1972 \textcolor{comment}{     */}
1973     \textcolor{keyword}{struct }stream\_state *stream = NULL;
1974 
1975     \textcolor{keywordflow}{do} \{
1976       stream = new\_stream(&global, stream);
1977       stream\_cnt++;
1978       \textcolor{keywordflow}{if} (!streams)
1979         streams = stream;
1980     \} \textcolor{keywordflow}{while} (parse\_stream\_params(&global, stream, argv));
1981   \}
1982 
1983   \textcolor{comment}{/* Check for unrecognized options */}
1984   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
1985     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && argi[0][1])
1986       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
1987 
1988   \textcolor{comment}{/* Handle non-option arguments */}
1989   input.fn = argv[0];
1990 
1991   \textcolor{keywordflow}{if} (!input.fn)
1992     usage\_exit();
1993 
1994 \textcolor{preprocessor}{#if CONFIG\_NON420}
1995   \textcolor{comment}{/* Decide if other chroma subsamplings than 4:2:0 are supported */}
1996   \textcolor{keywordflow}{if} (global.codec->fourcc == VP9\_FOURCC)
1997     input.only\_i420 = 0;
1998 \textcolor{preprocessor}{#endif}
1999 
2000   \textcolor{keywordflow}{for} (pass = global.pass ? global.pass - 1 : 0; pass < global.passes; pass++) \{
2001     \textcolor{keywordtype}{int} frames\_in = 0, seen\_frames = 0;
2002     int64\_t estimated\_time\_left = -1;
2003     int64\_t average\_rate = -1;
2004     off\_t lagged\_count = 0;
2005 
2006     open\_input\_file(&input);
2007 
2008     \textcolor{comment}{/* If the input file doesn't specify its w/h (raw files), try to get}
2009 \textcolor{comment}{     * the data from the first stream's configuration.}
2010 \textcolor{comment}{     */}
2011     \textcolor{keywordflow}{if} (!input.w || !input.h)
2012       FOREACH\_STREAM( \{
2013       \textcolor{keywordflow}{if} (stream->config.cfg.g\_w && stream->config.cfg.g\_h) \{
2014         input.w = stream->config.cfg.g\_w;
2015         input.h = stream->config.cfg.g\_h;
2016         break;
2017       \}
2018     \});
2019 
2020     \textcolor{comment}{/* Update stream configurations from the input file's parameters */}
2021     \textcolor{keywordflow}{if} (!input.w || !input.h)
2022       fatal(\textcolor{stringliteral}{"Specify stream dimensions with --width (-w) "}
2023             \textcolor{stringliteral}{" and --height (-h)"});
2024     FOREACH\_STREAM(set\_stream\_dimensions(stream, input.w, input.h));
2025     FOREACH\_STREAM(validate\_stream\_config(stream));
2026 
2027     \textcolor{comment}{/* Ensure that --passes and --pass are consistent. If --pass is set and}
2028 \textcolor{comment}{     * --passes=2, ensure --fpf was set.}
2029 \textcolor{comment}{     */}
2030     \textcolor{keywordflow}{if} (global.pass && global.passes == 2)
2031       FOREACH\_STREAM( \{
2032       \textcolor{keywordflow}{if} (!stream->config.stats\_fn)
2033         die(\textcolor{stringliteral}{"Stream %d: Must specify --fpf when --pass=%d"}
2034         \textcolor{stringliteral}{" and --passes=2\(\backslash\)n"}, stream->index, global.pass);
2035     \});
2036 
2037     \textcolor{comment}{/* Use the frame rate from the file only if none was specified}
2038 \textcolor{comment}{     * on the command-line.}
2039 \textcolor{comment}{     */}
2040     \textcolor{keywordflow}{if} (!global.have\_framerate)
2041       global.framerate = input.framerate;
2042 
2043     FOREACH\_STREAM(set\_default\_kf\_interval(stream, &global));
2044 
2045     \textcolor{comment}{/* Show configuration */}
2046     \textcolor{keywordflow}{if} (global.verbose && pass == 0)
2047       FOREACH\_STREAM(show\_stream\_config(stream, &global, &input));
2048 
2049     \textcolor{keywordflow}{if} (pass == (global.pass ? global.pass - 1 : 0)) \{
2050       \textcolor{keywordflow}{if} (input.file\_type == FILE\_TYPE\_Y4M)
2051         \textcolor{comment}{/*The Y4M reader does its own allocation.}
2052 \textcolor{comment}{          Just initialize this here to avoid problems if we never read any}
2053 \textcolor{comment}{           frames.*/}
2054         memset(&raw, 0, \textcolor{keyword}{sizeof}(raw));
2055       \textcolor{keywordflow}{else}
2056         \hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(&raw,
2057                       input.use\_i420 ? \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420}
2058                       : \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193a6e4e8961bbcf96478c300dc4c3e1dc18}{VPX\_IMG\_FMT\_YV12},
2059                       input.w, input.h, 32);
2060 
2061       FOREACH\_STREAM(init\_rate\_histogram(&stream->rate\_hist,
2062                                          &stream->config.cfg,
2063                                          &global.framerate));
2064     \}
2065 
2066     FOREACH\_STREAM(setup\_pass(stream, &global, pass));
2067     FOREACH\_STREAM(open\_output\_file(stream, &global));
2068     FOREACH\_STREAM(initialize\_encoder(stream, &global));
2069 
2070     frame\_avail = 1;
2071     got\_data = 0;
2072 
2073     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
2074       \textcolor{keyword}{struct }vpx\_usec\_timer timer;
2075 
2076       \textcolor{keywordflow}{if} (!global.limit || frames\_in < global.limit) \{
2077         frame\_avail = read\_frame(&input, &raw);
2078 
2079         \textcolor{keywordflow}{if} (frame\_avail)
2080           frames\_in++;
2081         seen\_frames = frames\_in > global.skip\_frames ?
2082                           frames\_in - global.skip\_frames : 0;
2083 
2084         \textcolor{keywordflow}{if} (!global.quiet) \{
2085           \textcolor{keywordtype}{float} fps = usec\_to\_fps(cx\_time, seen\_frames);
2086           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d "}, pass + 1, global.passes);
2087 
2088           \textcolor{keywordflow}{if} (stream\_cnt == 1)
2089             fprintf(stderr,
2090                     \textcolor{stringliteral}{"frame %4d/%-4d %7"}PRId64\textcolor{stringliteral}{"B "},
2091                     frames\_in, streams->frames\_out, (int64\_t)streams->nbytes);
2092           \textcolor{keywordflow}{else}
2093             fprintf(stderr, \textcolor{stringliteral}{"frame %4d "}, frames\_in);
2094 
2095           fprintf(stderr, \textcolor{stringliteral}{"%7"}PRId64\textcolor{stringliteral}{" %s %.2f %s "},
2096                   cx\_time > 9999999 ? cx\_time / 1000 : cx\_time,
2097                   cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2098                   fps >= 1.0 ? fps : fps * 60,
2099                   fps >= 1.0 ? \textcolor{stringliteral}{"fps"} : \textcolor{stringliteral}{"fpm"});
2100           print\_time(\textcolor{stringliteral}{"ETA"}, estimated\_time\_left);
2101           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)033[K"});
2102         \}
2103 
2104       \} \textcolor{keywordflow}{else}
2105         frame\_avail = 0;
2106 
2107       \textcolor{keywordflow}{if} (frames\_in > global.skip\_frames) \{
2108         vpx\_usec\_timer\_start(&timer);
2109         FOREACH\_STREAM(encode\_frame(stream, &global,
2110                                     frame\_avail ? &raw : NULL,
2111                                     frames\_in));
2112         vpx\_usec\_timer\_mark(&timer);
2113         cx\_time += vpx\_usec\_timer\_elapsed(&timer);
2114 
2115         FOREACH\_STREAM(update\_quantizer\_histogram(stream));
2116 
2117         got\_data = 0;
2118         FOREACH\_STREAM(get\_cx\_data(stream, &global, &got\_data));
2119 
2120         \textcolor{keywordflow}{if} (!got\_data && input.length && !streams->frames\_out) \{
2121           lagged\_count = global.limit ? seen\_frames : ftello(input.file);
2122         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.length) \{
2123           int64\_t remaining;
2124           int64\_t rate;
2125 
2126           \textcolor{keywordflow}{if} (global.limit) \{
2127             \textcolor{keywordtype}{int} frame\_in\_lagged = (seen\_frames - lagged\_count) * 1000;
2128 
2129             rate = cx\_time ? frame\_in\_lagged * (int64\_t)1000000 / cx\_time : 0;
2130             remaining = 1000 * (global.limit - global.skip\_frames
2131                                 - seen\_frames + lagged\_count);
2132           \} \textcolor{keywordflow}{else} \{
2133             off\_t input\_pos = ftello(input.file);
2134             off\_t input\_pos\_lagged = input\_pos - lagged\_count;
2135             int64\_t limit = input.length;
2136 
2137             rate = cx\_time ? input\_pos\_lagged * (int64\_t)1000000 / cx\_time : 0;
2138             remaining = limit - input\_pos + lagged\_count;
2139           \}
2140 
2141           average\_rate = (average\_rate <= 0)
2142               ? rate
2143               : (average\_rate * 7 + rate) / 8;
2144           estimated\_time\_left = average\_rate ? remaining / average\_rate : -1;
2145         \}
2146 
2147         \textcolor{keywordflow}{if} (got\_data && global.test\_decode != TEST\_DECODE\_OFF)
2148           FOREACH\_STREAM(test\_decode(stream, global.test\_decode, global.codec));
2149       \}
2150 
2151       fflush(stdout);
2152     \}
2153 
2154     \textcolor{keywordflow}{if} (stream\_cnt > 1)
2155       fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2156 
2157     \textcolor{keywordflow}{if} (!global.quiet)
2158       FOREACH\_STREAM(fprintf(
2159                        stderr,
2160                        \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d frame %4d/%-4d %7"}PRId64\textcolor{stringliteral}{"B %7lub/f %7"}PRId64\textcolor{stringliteral}{"b/s"}
2161                        \textcolor{stringliteral}{" %7"}PRId64\textcolor{stringliteral}{" %s (%.2f fps)\(\backslash\)033[K\(\backslash\)n"}, pass + 1,
2162                        global.passes, frames\_in, stream->frames\_out, (int64\_t)stream->nbytes,
2163                        seen\_frames ? (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})(stream->nbytes * 8 / seen\_frames) : 0,
2164                        seen\_frames ? (int64\_t)stream->nbytes * 8
2165                        * (int64\_t)global.framerate.num / global.framerate.den
2166                        / seen\_frames
2167                        : 0,
2168                        stream->cx\_time > 9999999 ? stream->cx\_time / 1000 : stream->cx\_time,
2169                        stream->cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2170                        usec\_to\_fps(stream->cx\_time, seen\_frames));
2171                     );
2172 
2173     \textcolor{keywordflow}{if} (global.show\_psnr)
2174       FOREACH\_STREAM(show\_psnr(stream));
2175 
2176     FOREACH\_STREAM(\hyperlink{group__codec_ga6ae21d96909660d0ac978b59a863f53b}{vpx\_codec\_destroy}(&stream->encoder));
2177 
2178     \textcolor{keywordflow}{if} (global.test\_decode != TEST\_DECODE\_OFF) \{
2179       FOREACH\_STREAM(\hyperlink{group__codec_ga6ae21d96909660d0ac978b59a863f53b}{vpx\_codec\_destroy}(&stream->decoder));
2180     \}
2181 
2182     close\_input\_file(&input);
2183 
2184     \textcolor{keywordflow}{if} (global.test\_decode == TEST\_DECODE\_FATAL) \{
2185       FOREACH\_STREAM(res |= stream->mismatch\_seen);
2186     \}
2187     FOREACH\_STREAM(close\_output\_file(stream, global.codec->fourcc));
2188 
2189     FOREACH\_STREAM(stats\_close(&stream->stats, global.passes - 1));
2190 
2191     \textcolor{keywordflow}{if} (global.pass)
2192       \textcolor{keywordflow}{break};
2193   \}
2194 
2195   \textcolor{keywordflow}{if} (global.show\_q\_hist\_buckets)
2196     FOREACH\_STREAM(show\_q\_histogram(stream->counts,
2197                                     global.show\_q\_hist\_buckets));
2198 
2199   \textcolor{keywordflow}{if} (global.show\_rate\_hist\_buckets)
2200     FOREACH\_STREAM(show\_rate\_histogram(&stream->rate\_hist,
2201                                        &stream->config.cfg,
2202                                        global.show\_rate\_hist\_buckets));
2203   FOREACH\_STREAM(destroy\_rate\_histogram(&stream->rate\_hist));
2204 
2205 \textcolor{preprocessor}{#if CONFIG\_INTERNAL\_STATS}
2206   \textcolor{comment}{/* TODO(jkoleszar): This doesn't belong in this executable. Do it for now,}
2207 \textcolor{comment}{   * to match some existing utilities.}
2208 \textcolor{comment}{   */}
2209   \textcolor{keywordflow}{if} (!(global.pass == 1 && global.passes == 2))
2210     FOREACH\_STREAM(\{
2211       FILE *f = fopen(\textcolor{stringliteral}{"opsnr.stt"}, \textcolor{stringliteral}{"a"});
2212       \textcolor{keywordflow}{if} (stream->mismatch\_seen) \{
2213         fprintf(f, \textcolor{stringliteral}{"First mismatch occurred in frame %d\(\backslash\)n"},
2214                 stream->mismatch\_seen);
2215       \} \textcolor{keywordflow}{else} \{
2216         fprintf(f, \textcolor{stringliteral}{"No mismatch detected in recon buffers\(\backslash\)n"});
2217       \}
2218       fclose(f);
2219     \});
2220 \textcolor{preprocessor}{#endif}
2221 
2222   \hyperlink{vpx__image_8h_af47ebaf286812d037425d41990d48a17}{vpx\_img\_free}(&raw);
2223   free(argv);
2224   free(streams);
2225   \textcolor{keywordflow}{return} res ? EXIT\_FAILURE : EXIT\_SUCCESS;
2226 \}
\end{DoxyCodeInclude}
 \hypertarget{example_vp8_scalable_patterns}{}\subsection{vp8\+\_\+scalable\+\_\+patterns}\label{example_vp8_scalable_patterns}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ *  Use of this source code is governed by a BSD-style license}
5 \textcolor{comment}{ *  that can be found in the LICENSE file in the root of the source}
6 \textcolor{comment}{ *  tree. An additional intellectual property rights grant can be found}
7 \textcolor{comment}{ *  in the file PATENTS.  All contributing project authors may}
8 \textcolor{comment}{ *  be found in the AUTHORS file in the root of the source tree.}
9 \textcolor{comment}{ */}
10 
11 
12 \textcolor{comment}{/*}
13 \textcolor{comment}{ * This is an example demonstrating how to implement a multi-layer VP8}
14 \textcolor{comment}{ * encoding scheme based on temporal scalability for video applications}
15 \textcolor{comment}{ * that benefit from a scalable bitstream.}
16 \textcolor{comment}{ */}
17 \textcolor{preprocessor}{#include <stdio.h>}
18 \textcolor{preprocessor}{#include <stdlib.h>}
19 \textcolor{preprocessor}{#include <stdarg.h>}
20 \textcolor{preprocessor}{#include <string.h>}
21 \textcolor{preprocessor}{#define VPX\_CODEC\_DISABLE\_COMPAT 1}
22 \textcolor{preprocessor}{#include "\hyperlink{vpx__encoder_8h}{vpx/vpx\_encoder.h}"}
23 \textcolor{preprocessor}{#include "\hyperlink{vp8cx_8h}{vpx/vp8cx.h}"}
24 \textcolor{preprocessor}{#define interface (vpx\_codec\_vp8\_cx())}
25 \textcolor{preprocessor}{#define fourcc    0x30385056}
26 
27 \textcolor{preprocessor}{#define IVF\_FILE\_HDR\_SZ  (32)}
28 \textcolor{preprocessor}{#define IVF\_FRAME\_HDR\_SZ (12)}
29 
30 \textcolor{keyword}{static} \textcolor{keywordtype}{void} mem\_put\_le16(\textcolor{keywordtype}{char} *mem, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} val) \{
31     mem[0] = val;
32     mem[1] = val>>8;
33 \}
34 
35 \textcolor{keyword}{static} \textcolor{keywordtype}{void} mem\_put\_le32(\textcolor{keywordtype}{char} *mem, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} val) \{
36     mem[0] = val;
37     mem[1] = val>>8;
38     mem[2] = val>>16;
39     mem[3] = val>>24;
40 \}
41 
42 \textcolor{keyword}{static} \textcolor{keywordtype}{void} die(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
43     va\_list ap;
44 
45     va\_start(ap, fmt);
46     vprintf(fmt, ap);
47     \textcolor{keywordflow}{if}(fmt[strlen(fmt)-1] != \textcolor{charliteral}{'\(\backslash\)n'})
48         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
49     exit(EXIT\_FAILURE);
50 \}
51 
52 \textcolor{keyword}{static} \textcolor{keywordtype}{void} die\_codec(\hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s) \{
53     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga29273cb552ed1a437fe263c4a0a54300}{vpx\_codec\_error\_detail}(ctx);
54 
55     printf(\textcolor{stringliteral}{"%s: %s\(\backslash\)n"}, s, \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(ctx));
56     \textcolor{keywordflow}{if}(detail)
57         printf(\textcolor{stringliteral}{"    %s\(\backslash\)n"},detail);
58     exit(EXIT\_FAILURE);
59 \}
60 
61 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(FILE *f, \hyperlink{structvpx__image}{vpx\_image\_t} *img) \{
62     \textcolor{keywordtype}{size\_t} nbytes, to\_read;
63     \textcolor{keywordtype}{int}    res = 1;
64 
65     to\_read = img->\hyperlink{structvpx__image_ac7b7d569142f878155b28141653adcd6}{w}*img->\hyperlink{structvpx__image_a9d1070804dfe08cd5becd68d597fee69}{h}*3/2;
66     nbytes = fread(img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[0], 1, to\_read, f);
67     \textcolor{keywordflow}{if}(nbytes != to\_read) \{
68         res = 0;
69         \textcolor{keywordflow}{if}(nbytes > 0)
70             printf(\textcolor{stringliteral}{"Warning: Read partial frame. Check your width & height!\(\backslash\)n"});
71     \}
72     \textcolor{keywordflow}{return} res;
73 \}
74 
75 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_file\_header(FILE *outfile,
76                                   \textcolor{keyword}{const} \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *cfg,
77                                   \textcolor{keywordtype}{int} frame\_cnt) \{
78     \textcolor{keywordtype}{char} header[32];
79 
80     \textcolor{keywordflow}{if}(cfg->\hyperlink{structvpx__codec__enc__cfg_a70d62d87aae7d1168746577f14a6dccf}{g\_pass} != \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa7b6943a41868e8e26a77e9500f139ca1}{VPX\_RC\_ONE\_PASS} && cfg->\hyperlink{structvpx__codec__enc__cfg_a70d62d87aae7d1168746577f14a6dccf}{g\_pass} != 
      \hyperlink{group__encoder_gga476c5417f9c15a1dc5d3f68fa44c493fa65da543b956d6a9b1f301ab8cc90d3a7}{VPX\_RC\_LAST\_PASS})
81         \textcolor{keywordflow}{return};
82     header[0] = \textcolor{charliteral}{'D'};
83     header[1] = \textcolor{charliteral}{'K'};
84     header[2] = \textcolor{charliteral}{'I'};
85     header[3] = \textcolor{charliteral}{'F'};
86     mem\_put\_le16(header+4,  0);                   \textcolor{comment}{/* version */}
87     mem\_put\_le16(header+6,  32);                  \textcolor{comment}{/* headersize */}
88     mem\_put\_le32(header+8,  fourcc);              \textcolor{comment}{/* headersize */}
89     mem\_put\_le16(header+12, cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w});            \textcolor{comment}{/* width */}
90     mem\_put\_le16(header+14, cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h});            \textcolor{comment}{/* height */}
91     mem\_put\_le32(header+16, cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den}); \textcolor{comment}{/* rate */}
92     mem\_put\_le32(header+20, cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num}); \textcolor{comment}{/* scale */}
93     mem\_put\_le32(header+24, frame\_cnt);           \textcolor{comment}{/* length */}
94     mem\_put\_le32(header+28, 0);                   \textcolor{comment}{/* unused */}
95 
96     (void) fwrite(header, 1, 32, outfile);
97 \}
98 
99 
100 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_frame\_header(FILE *outfile,
101                                    \textcolor{keyword}{const} \hyperlink{structvpx__codec__cx__pkt}{vpx\_codec\_cx\_pkt\_t} *pkt)
102 \{
103     \textcolor{keywordtype}{char}             header[12];
104     \hyperlink{group__encoder_ga7e711b0a71c65aef8f0faea8bd57b05f}{vpx\_codec\_pts\_t}  pts;
105 
106     \textcolor{keywordflow}{if}(pkt->\hyperlink{structvpx__codec__cx__pkt_a41f395b39516343c1329a4a85a0084f2}{kind} != \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a2261aae5594289400e812fb1e6b6b0cc}{VPX\_CODEC\_CX\_FRAME\_PKT})
107         \textcolor{keywordflow}{return};
108 
109     pts = pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.pts;
110     mem\_put\_le32(header, pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz);
111     mem\_put\_le32(header+4, pts&0xFFFFFFFF);
112     mem\_put\_le32(header+8, pts >> 32);
113 
114     (void) fwrite(header, 1, 12, outfile);
115 \}
116 
117 \textcolor{keyword}{static} \textcolor{keywordtype}{int} mode\_to\_num\_layers[12] = \{1, 2, 2, 3, 3, 3, 3, 5, 2, 3, 3, 3\};
118 
119 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
120     FILE                *infile, *outfile[\hyperlink{group__encoder_ga2715ac3dd8bf2f5438c4bbfc82788eb2}{VPX\_TS\_MAX\_LAYERS}];
121     \hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t}      codec;
122     \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t}  cfg;
123     \textcolor{keywordtype}{int}                  frame\_cnt = 0;
124     \hyperlink{structvpx__image}{vpx\_image\_t}          raw;
125     \hyperlink{group__codec_gada1084710837ad363b92f2379dd2b8d2}{vpx\_codec\_err\_t}      res;
126     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}         width;
127     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}         height;
128     \textcolor{keywordtype}{int}                  frame\_avail;
129     \textcolor{keywordtype}{int}                  got\_data;
130     \textcolor{keywordtype}{int}                  flags = 0;
131     \textcolor{keywordtype}{int}                  i;
132     \textcolor{keywordtype}{int}                  pts = 0;              \textcolor{comment}{/* PTS starts at 0 */}
133     \textcolor{keywordtype}{int}                  frame\_duration = 1;   \textcolor{comment}{/* 1 timebase tick per frame */}
134 
135     \textcolor{keywordtype}{int}                  layering\_mode = 0;
136     \textcolor{keywordtype}{int}                  frames\_in\_layer[\hyperlink{group__encoder_ga2715ac3dd8bf2f5438c4bbfc82788eb2}{VPX\_TS\_MAX\_LAYERS}] = \{0\};
137     \textcolor{keywordtype}{int}                  layer\_flags[\hyperlink{group__encoder_ga684b48cb6e47a258247637186557eb19}{VPX\_TS\_MAX\_PERIODICITY}] = \{0\};
138     \textcolor{keywordtype}{int}                  flag\_periodicity;
139     \textcolor{keywordtype}{int}                  max\_intra\_size\_pct;
140 
141     \textcolor{comment}{/* Check usage and arguments */}
142     \textcolor{keywordflow}{if} (argc < 9)
143         die(\textcolor{stringliteral}{"Usage: %s <infile> <outfile> <width> <height> <rate\_num> "}
144             \textcolor{stringliteral}{" <rate\_den> <mode> <Rate\_0> ... <Rate\_nlayers-1>\(\backslash\)n"}, argv[0]);
145 
146     width  = strtol (argv[3], NULL, 0);
147     height = strtol (argv[4], NULL, 0);
148     \textcolor{keywordflow}{if} (width < 16 || width%2 || height <16 || height%2)
149         die (\textcolor{stringliteral}{"Invalid resolution: %d x %d"}, width, height);
150 
151     \textcolor{keywordflow}{if} (!sscanf(argv[7], \textcolor{stringliteral}{"%d"}, &layering\_mode))
152         die (\textcolor{stringliteral}{"Invalid mode %s"}, argv[7]);
153     \textcolor{keywordflow}{if} (layering\_mode<0 || layering\_mode>11)
154         die (\textcolor{stringliteral}{"Invalid mode (0..11) %s"}, argv[7]);
155 
156     \textcolor{keywordflow}{if} (argc != 8+mode\_to\_num\_layers[layering\_mode])
157         die (\textcolor{stringliteral}{"Invalid number of arguments"});
158 
159     \textcolor{keywordflow}{if} (!\hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc} (&raw, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420}, width, height, 32))
160         die (\textcolor{stringliteral}{"Failed to allocate image"}, width, height);
161 
162     printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"},\hyperlink{group__codec_ga9eee39f450d8cdcf5aba0e2bda6e5aa8}{vpx\_codec\_iface\_name}(interface));
163 
164     \textcolor{comment}{/* Populate encoder configuration */}
165     res = \hyperlink{group__encoder_ga9ab8c79623312e9c5d5405d66a788f59}{vpx\_codec\_enc\_config\_default}(interface, &cfg, 0);
166     \textcolor{keywordflow}{if}(res) \{
167         printf(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_gaaddf5c1f609ef18c7c8800d102fcefa6}{vpx\_codec\_err\_to\_string}(res));
168         \textcolor{keywordflow}{return} EXIT\_FAILURE;
169     \}
170 
171     \textcolor{comment}{/* Update the default configuration with our settings */}
172     cfg.\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} = width;
173     cfg.\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} = height;
174 
175     \textcolor{comment}{/* Timebase format e.g. 30fps: numerator=1, demoninator=30 */}
176     \textcolor{keywordflow}{if} (!sscanf (argv[5], \textcolor{stringliteral}{"%d"}, &cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} ))
177         die (\textcolor{stringliteral}{"Invalid timebase numerator %s"}, argv[5]);
178     \textcolor{keywordflow}{if} (!sscanf (argv[6], \textcolor{stringliteral}{"%d"}, &cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} ))
179         die (\textcolor{stringliteral}{"Invalid timebase denominator %s"}, argv[6]);
180 
181     \textcolor{keywordflow}{for} (i=8; i<8+mode\_to\_num\_layers[layering\_mode]; i++)
182         \textcolor{keywordflow}{if} (!sscanf(argv[i], \textcolor{stringliteral}{"%ud"}, &cfg.\hyperlink{structvpx__codec__enc__cfg_aba7ceb7a90500a8f76aff89575737f3a}{ts\_target\_bitrate}[i-8]))
183             die (\textcolor{stringliteral}{"Invalid data rate %s"}, argv[i]);
184 
185     \textcolor{comment}{/* Real time parameters */}
186     cfg.\hyperlink{structvpx__codec__enc__cfg_a619269f9a6904de58c4790e6806a3905}{rc\_dropframe\_thresh} = 0;
187     cfg.\hyperlink{structvpx__codec__enc__cfg_a99c415edb6c6f909a095a57c3430a116}{rc\_end\_usage}        = \hyperlink{group__encoder_ggaf50e74d91be4cae6f70dfeba5b7410d2a8b02853cb35790d60cc171a11f6c268a}{VPX\_CBR};
188     cfg.\hyperlink{structvpx__codec__enc__cfg_a02a4e2f18fb0fdfff44df8b0d9a99d6c}{rc\_resize\_allowed}   = 0;
189     cfg.\hyperlink{structvpx__codec__enc__cfg_a1324600e3c63faaa7717e85cf6509dd9}{rc\_min\_quantizer}    = 2;
190     cfg.\hyperlink{structvpx__codec__enc__cfg_a8abdd985d317b720e142335887d737df}{rc\_max\_quantizer}    = 56;
191     cfg.\hyperlink{structvpx__codec__enc__cfg_ad279fbb0a9fe9395340913161e28651a}{rc\_undershoot\_pct}   = 100;
192     cfg.\hyperlink{structvpx__codec__enc__cfg_a4f2fbd015c1b1f395cc4a4b03d4ead5f}{rc\_overshoot\_pct}    = 15;
193     cfg.\hyperlink{structvpx__codec__enc__cfg_aa9e4d6405994ef42d61d478cf6e0d5e0}{rc\_buf\_initial\_sz}   = 500;
194     cfg.\hyperlink{structvpx__codec__enc__cfg_aafde485867e040a58504ad796e79e47f}{rc\_buf\_optimal\_sz}   = 600;
195     cfg.\hyperlink{structvpx__codec__enc__cfg_a61866272bb588cd86d28834f420430f0}{rc\_buf\_sz}           = 1000;
196 
197     \textcolor{comment}{/* Enable error resilient mode */}
198     cfg.\hyperlink{structvpx__codec__enc__cfg_a4e17173b66ca0d7dfba9978625d7ba76}{g\_error\_resilient} = 1;
199     cfg.\hyperlink{structvpx__codec__enc__cfg_a992668d9e30305f3f7ab2672ea31a890}{g\_lag\_in\_frames}   = 0;
200     cfg.\hyperlink{structvpx__codec__enc__cfg_a491d67f061dcdb13f60c017563e9d788}{kf\_mode}           = \hyperlink{group__encoder_gga9f461802aa4db35c04a8b23837987f40a56513f60cbf3434ca0092173005d0ab2}{VPX\_KF\_DISABLED};
201 
202     \textcolor{comment}{/* Disable automatic keyframe placement */}
203     cfg.\hyperlink{structvpx__codec__enc__cfg_a0a7b5444ecb09745cbe8d5af17553846}{kf\_min\_dist} = cfg.\hyperlink{structvpx__codec__enc__cfg_ae018440136e271743376730413d25a9b}{kf\_max\_dist} = 3000;
204 
205     \textcolor{comment}{/* Default setting for bitrate: used in special case of 1 layer (case 0). */}
206     cfg.\hyperlink{structvpx__codec__enc__cfg_ab8339685175d66710f482706cc9f0aed}{rc\_target\_bitrate} = cfg.\hyperlink{structvpx__codec__enc__cfg_aba7ceb7a90500a8f76aff89575737f3a}{ts\_target\_bitrate}[0];
207 
208     \textcolor{comment}{/* Temporal scaling parameters: */}
209     \textcolor{comment}{/* NOTE: The 3 prediction frames cannot be used interchangeably due to}
210 \textcolor{comment}{     * differences in the way they are handled throughout the code. The}
211 \textcolor{comment}{     * frames should be allocated to layers in the order LAST, GF, ARF.}
212 \textcolor{comment}{     * Other combinations work, but may produce slightly inferior results.}
213 \textcolor{comment}{     */}
214     \textcolor{keywordflow}{switch} (layering\_mode)
215     \{
216     \textcolor{keywordflow}{case} 0:
217     \{
218         \textcolor{comment}{/* 1-layer */}
219        \textcolor{keywordtype}{int} ids[1] = \{0\};
220        cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 1;
221        cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 1;
222        cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 1;
223        memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
224 
225        flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
226 
227        \textcolor{comment}{// Update L only.}
228        layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
229                         \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
230        \textcolor{keywordflow}{break};
231     \}
232     \textcolor{keywordflow}{case} 1:
233     \{
234         \textcolor{comment}{/* 2-layers, 2-frame period */}
235         \textcolor{keywordtype}{int} ids[2] = \{0,1\};
236         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 2;
237         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 2;
238         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 2;
239         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 1;
240         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
241 
242         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
243 \textcolor{preprocessor}{#if 1}
244         \textcolor{comment}{/* 0=L, 1=GF, Intra-layer prediction enabled */}
245         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
246                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
247                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF};
248         layer\_flags[1] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
249                          \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF};
250 \textcolor{preprocessor}{#else}
251         \textcolor{comment}{/* 0=L, 1=GF, Intra-layer prediction disabled */}
252         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
253                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
254                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF};
255         layer\_flags[1] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
256                          \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__vp8__encoder_gafb51c67e5743275146bc1fc425727da3}{VP8\_EFLAG\_NO\_REF\_LAST};
257 \textcolor{preprocessor}{#endif}
258         \textcolor{keywordflow}{break};
259     \}
260 
261     \textcolor{keywordflow}{case} 2:
262     \{
263         \textcolor{comment}{/* 2-layers, 3-frame period */}
264         \textcolor{keywordtype}{int} ids[3] = \{0,1,1\};
265         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 2;
266         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 3;
267         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 3;
268         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 1;
269         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
270 
271         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
272 
273         \textcolor{comment}{/* 0=L, 1=GF, Intra-layer prediction enabled */}
274         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
275                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
276                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
277         layer\_flags[1] =
278         layer\_flags[2] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF}  |
279                          \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
280                                                 \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
281         \textcolor{keywordflow}{break};
282     \}
283 
284     \textcolor{keywordflow}{case} 3:
285     \{
286         \textcolor{comment}{/* 3-layers, 6-frame period */}
287         \textcolor{keywordtype}{int} ids[6] = \{0,2,2,1,2,2\};
288         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
289         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 6;
290         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 6;
291         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 3;
292         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
293         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
294 
295         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
296 
297         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled */}
298         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
299                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
300                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
301         layer\_flags[3] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
302                                                 \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
303         layer\_flags[1] =
304         layer\_flags[2] =
305         layer\_flags[4] =
306         layer\_flags[5] = \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
307         \textcolor{keywordflow}{break};
308     \}
309 
310     \textcolor{keywordflow}{case} 4:
311     \{
312         \textcolor{comment}{/* 3-layers, 4-frame period */}
313         \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
314         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
315         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
316         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
317         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
318         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
319         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
320 
321         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
322 
323         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF, Intra-layer prediction disabled */}
324         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
325                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
326                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
327         layer\_flags[2] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
328                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
329                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
330         layer\_flags[1] =
331         layer\_flags[3] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
332                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
333                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
334         \textcolor{keywordflow}{break};
335     \}
336 
337     \textcolor{keywordflow}{case} 5:
338     \{
339         \textcolor{comment}{/* 3-layers, 4-frame period */}
340         \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
341         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
342         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
343         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
344         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
345         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
346         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
347 
348         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
349 
350         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled in layer 1,}
351 \textcolor{comment}{         * disabled in layer 2}
352 \textcolor{comment}{         */}
353         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
354                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
355                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
356         layer\_flags[2] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
357                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
358         layer\_flags[1] =
359         layer\_flags[3] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
360                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
361                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
362         \textcolor{keywordflow}{break};
363     \}
364 
365     \textcolor{keywordflow}{case} 6:
366     \{
367         \textcolor{comment}{/* 3-layers, 4-frame period */}
368         \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
369         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
370         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
371         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
372         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
373         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
374         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
375 
376         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
377 
378         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF, Intra-layer prediction enabled */}
379         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
380                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
381                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
382         layer\_flags[2] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
383                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
384         layer\_flags[1] =
385         layer\_flags[3] = \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF};
386         \textcolor{keywordflow}{break};
387     \}
388 
389     \textcolor{keywordflow}{case} 7:
390     \{
391         \textcolor{comment}{/* NOTE: Probably of academic interest only */}
392 
393         \textcolor{comment}{/* 5-layers, 16-frame period */}
394         \textcolor{keywordtype}{int} ids[16] = \{0,4,3,4,2,4,3,4,1,4,3,4,2,4,3,4\};
395         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 5;
396         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 16;
397         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 16;
398         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 8;
399         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 4;
400         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[3] = 2;
401         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[4] = 1;
402         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
403 
404         flag\_periodicity = cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity};
405 
406         layer\_flags[0]  = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF};
407         layer\_flags[1]  =
408         layer\_flags[3]  =
409         layer\_flags[5]  =
410         layer\_flags[7]  =
411         layer\_flags[9]  =
412         layer\_flags[11] =
413         layer\_flags[13] =
414         layer\_flags[15] = \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
415                           \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF}   |
416                           \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
417         layer\_flags[2]  =
418         layer\_flags[6]  =
419         layer\_flags[10] =
420         layer\_flags[14] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF};
421         layer\_flags[4]  =
422         layer\_flags[12] = \hyperlink{group__vp8__encoder_gafb51c67e5743275146bc1fc425727da3}{VP8\_EFLAG\_NO\_REF\_LAST} |
423                           \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
424         layer\_flags[8]  = \hyperlink{group__vp8__encoder_gafb51c67e5743275146bc1fc425727da3}{VP8\_EFLAG\_NO\_REF\_LAST} | 
      \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF};
425         \textcolor{keywordflow}{break};
426     \}
427 
428     \textcolor{keywordflow}{case} 8:
429     \{
430         \textcolor{comment}{/* 2-layers, with sync point at first frame of layer 1. */}
431         \textcolor{keywordtype}{int} ids[2] = \{0,1\};
432         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 2;
433         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 2;
434         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 2;
435         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 1;
436         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
437 
438         flag\_periodicity = 8;
439 
440         \textcolor{comment}{/* 0=L, 1=GF */}
441         \textcolor{comment}{// ARF is used as predictor for all frames, and is only updated on}
442         \textcolor{comment}{// key frame. Sync point every 8 frames.}
443 
444         \textcolor{comment}{// Layer 0: predict from L and ARF, update L and G.}
445         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
446                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} |
447                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
448 
449         \textcolor{comment}{// Layer 1: sync point: predict from L and ARF, and update G.}
450         layer\_flags[1] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} |
451                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
452                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
453 
454         \textcolor{comment}{// Layer 0, predict from L and ARF, update L.}
455         layer\_flags[2] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF}  |
456                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF}  |
457                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
458 
459         \textcolor{comment}{// Layer 1: predict from L, G and ARF, and update G.}
460         layer\_flags[3] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
461                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
462                          \hyperlink{group__vp8__encoder_ga5b91ad179910d4efc23aef66c7b2148b}{VP8\_EFLAG\_NO\_UPD\_ENTROPY};
463 
464         \textcolor{comment}{// Layer 0}
465         layer\_flags[4] = layer\_flags[2];
466 
467         \textcolor{comment}{// Layer 1}
468         layer\_flags[5] = layer\_flags[3];
469 
470         \textcolor{comment}{// Layer 0}
471         layer\_flags[6] = layer\_flags[4];
472 
473         \textcolor{comment}{// Layer 1}
474         layer\_flags[7] = layer\_flags[5];
475         \textcolor{keywordflow}{break};
476     \}
477 
478     \textcolor{keywordflow}{case} 9:
479     \{
480         \textcolor{comment}{/* 3-layers */}
481         \textcolor{comment}{// Sync points for layer 1 and 2 every 8 frames.}
482 
483         \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
484         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
485         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
486         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
487         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
488         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
489         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
490 
491         flag\_periodicity = 8;
492 
493         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF */}
494         layer\_flags[0] = \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
495                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
496                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
497         layer\_flags[1] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
498                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF};
499         layer\_flags[2] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF}   | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
500                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
501         layer\_flags[3] =
502         layer\_flags[5] = \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF};
503         layer\_flags[4] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
504                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
505         layer\_flags[6] = \hyperlink{group__vp8__encoder_ga650ab0baea12be91082226a5cc18776a}{VP8\_EFLAG\_NO\_REF\_ARF} |
506                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF};
507         layer\_flags[7] = \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
508                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
509                          \hyperlink{group__vp8__encoder_ga5b91ad179910d4efc23aef66c7b2148b}{VP8\_EFLAG\_NO\_UPD\_ENTROPY};
510         \textcolor{keywordflow}{break};
511     \}
512     \textcolor{keywordflow}{case} 10:
513     \{
514         \textcolor{comment}{// 3-layers structure where ARF is used as predictor for all frames,}
515         \textcolor{comment}{// and is only updated on key frame.}
516         \textcolor{comment}{// Sync points for layer 1 and 2 every 8 frames.}
517 
518         \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
519         cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
520         cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
521         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
522         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
523         cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
524         memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
525 
526         flag\_periodicity = 8;
527 
528         \textcolor{comment}{/* 0=L, 1=GF, 2=ARF */}
529 
530         \textcolor{comment}{// Layer 0: predict from L and ARF; update L and G.}
531         layer\_flags[0] =  \hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF}  |
532                           \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
533                           \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF};
534 
535         \textcolor{comment}{// Layer 2: sync point: predict from L and ARF; update none.}
536         layer\_flags[1] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} |
537                          \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
538                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
539                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
540                          \hyperlink{group__vp8__encoder_ga5b91ad179910d4efc23aef66c7b2148b}{VP8\_EFLAG\_NO\_UPD\_ENTROPY};
541 
542         \textcolor{comment}{// Layer 1: sync point: predict from L and ARF; update G.}
543         layer\_flags[2] = \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF} |
544                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
545                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
546 
547         \textcolor{comment}{// Layer 2: predict from L, G, ARF; update none.}
548         layer\_flags[3] = \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
549                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
550                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
551                          \hyperlink{group__vp8__encoder_ga5b91ad179910d4efc23aef66c7b2148b}{VP8\_EFLAG\_NO\_UPD\_ENTROPY};
552 
553         \textcolor{comment}{// Layer 0: predict from L and ARF; update L.}
554         layer\_flags[4] = \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
555                          \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
556                          \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF};
557 
558         \textcolor{comment}{// Layer 2: predict from L, G, ARF; update none.}
559         layer\_flags[5] = layer\_flags[3];
560 
561         \textcolor{comment}{// Layer 1: predict from L, G, ARF; update G.}
562         layer\_flags[6] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
563                          \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
564 
565         \textcolor{comment}{// Layer 2: predict from L, G, ARF; update none.}
566         layer\_flags[7] = layer\_flags[3];
567         \textcolor{keywordflow}{break};
568     \}
569     \textcolor{keywordflow}{case} 11:
570     \textcolor{keywordflow}{default}:
571     \{
572        \textcolor{comment}{// 3-layers structure as in case 10, but no sync/refresh points for}
573        \textcolor{comment}{// layer 1 and 2.}
574 
575        \textcolor{keywordtype}{int} ids[4] = \{0,2,1,2\};
576        cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}     = 3;
577        cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}       = 4;
578        cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[0] = 4;
579        cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[1] = 2;
580        cfg.\hyperlink{structvpx__codec__enc__cfg_ad40c30846ef8ef1d8684f10a491ec535}{ts\_rate\_decimator}[2] = 1;
581        memcpy(cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}, ids, \textcolor{keyword}{sizeof}(ids));
582 
583        flag\_periodicity = 8;
584 
585        \textcolor{comment}{/* 0=L, 1=GF, 2=ARF */}
586 
587        \textcolor{comment}{// Layer 0: predict from L and ARF; update L.}
588        layer\_flags[0] = \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
589                         \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
590                         \hyperlink{group__vp8__encoder_gabb5e95343a2738abef44eca13059da33}{VP8\_EFLAG\_NO\_REF\_GF};
591        layer\_flags[4] = layer\_flags[0];
592 
593        \textcolor{comment}{// Layer 1: predict from L, G, ARF; update G.}
594        layer\_flags[2] = \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
595                         \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST};
596        layer\_flags[6] = layer\_flags[2];
597 
598        \textcolor{comment}{// Layer 2: predict from L, G, ARF; update none.}
599        layer\_flags[1] = \hyperlink{group__vp8__encoder_gab01d066c5236457d345ce1cab4c41d6b}{VP8\_EFLAG\_NO\_UPD\_GF} |
600                         \hyperlink{group__vp8__encoder_ga1cff46a5287e73a620660030d40b9e6c}{VP8\_EFLAG\_NO\_UPD\_ARF} |
601                         \hyperlink{group__vp8__encoder_ga602edb6b02a89cb2db7a16d6dffba583}{VP8\_EFLAG\_NO\_UPD\_LAST} |
602                         \hyperlink{group__vp8__encoder_ga5b91ad179910d4efc23aef66c7b2148b}{VP8\_EFLAG\_NO\_UPD\_ENTROPY};
603        layer\_flags[3] = layer\_flags[1];
604        layer\_flags[5] = layer\_flags[1];
605        layer\_flags[7] = layer\_flags[1];
606        \textcolor{keywordflow}{break};
607     \}
608     \}
609 
610     \textcolor{comment}{/* Open input file */}
611     \textcolor{keywordflow}{if}(!(infile = fopen(argv[1], \textcolor{stringliteral}{"rb"})))
612         die(\textcolor{stringliteral}{"Failed to open %s for reading"}, argv[1]);
613 
614     \textcolor{comment}{/* Open an output file for each stream */}
615     \textcolor{keywordflow}{for} (i=0; i<cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}; i++)
616     \{
617         \textcolor{keywordtype}{char} file\_name[512];
618         sprintf (file\_name, \textcolor{stringliteral}{"%s\_%d.ivf"}, argv[2], i);
619         \textcolor{keywordflow}{if} (!(outfile[i] = fopen(file\_name, \textcolor{stringliteral}{"wb"})))
620             die(\textcolor{stringliteral}{"Failed to open %s for writing"}, file\_name);
621         write\_ivf\_file\_header(outfile[i], &cfg, 0);
622     \}
623 
624     \textcolor{comment}{/* Initialize codec */}
625     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_ga3d490a2a9a6acd7c9ef82a603155f3cf}{vpx\_codec\_enc\_init} (&codec, interface, &cfg, 0))
626         die\_codec (&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
627 
628     \textcolor{comment}{/* Cap CPU & first I-frame size */}
629     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control} (&codec, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca953ff0eaa2fcdc2ecd627e449b026853}{VP8E\_SET\_CPUUSED},                -6);
630     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control} (&codec, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322ecab34559df04d3d662616300ed0682dcfd}{VP8E\_SET\_STATIC\_THRESHOLD},      1)
      ;
631     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control} (&codec, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca3fa90cb70bade72af3c2d8d91471a36c}{VP8E\_SET\_NOISE\_SENSITIVITY},      
       1);
632     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&codec, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca462a4f14f39a6eb5c4a4004fc8d0ad75}{VP8E\_SET\_TOKEN\_PARTITIONS},       1)
      ;
633 
634     max\_intra\_size\_pct = (int) (((\textcolor{keywordtype}{double})cfg.\hyperlink{structvpx__codec__enc__cfg_aafde485867e040a58504ad796e79e47f}{rc\_buf\_optimal\_sz} * 0.5)
635                          * ((double) cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} / cfg.
      \hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num})
636                          / 10.0);
637     \textcolor{comment}{/* printf ("max\_intra\_size\_pct=%d\(\backslash\)n", max\_intra\_size\_pct); */}
638 
639     \hyperlink{group__codec_gac1b91e04698c1bd4c0a2b8aa85b08cd2}{vpx\_codec\_control}(&codec, \hyperlink{group__vp8__encoder_gga6deae3d561c838952552c3d3756322eca09c69ff4a3aabdb307d4f24027dfc4c1}{VP8E\_SET\_MAX\_INTRA\_BITRATE\_PCT}
      ,
640                       max\_intra\_size\_pct);
641 
642     frame\_avail = 1;
643     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
644         \hyperlink{group__codec_ga6ea348f76b1f8a1fe50e14db684146c6}{vpx\_codec\_iter\_t} iter = NULL;
645         \textcolor{keyword}{const} \hyperlink{structvpx__codec__cx__pkt}{vpx\_codec\_cx\_pkt\_t} *pkt;
646 
647         flags = layer\_flags[frame\_cnt % flag\_periodicity];
648 
649         frame\_avail = read\_frame(infile, &raw);
650         \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf990542e2aeb389f05fae3e9c7803639}{vpx\_codec\_encode}(&codec, frame\_avail? &raw : NULL, pts,
651                             1, flags, \hyperlink{group__encoder_ga04253cc9ec1146d72fa8bb86bcf32144}{VPX\_DL\_REALTIME}))
652             die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode frame"});
653 
654         \textcolor{comment}{/* Reset KF flag */}
655         \textcolor{keywordflow}{if} (layering\_mode != 7)
656             layer\_flags[0] &= ~\hyperlink{group__encoder_ga4c4f4e3cbb5225d2c6c050e2d1e948fa}{VPX\_EFLAG\_FORCE\_KF};
657 
658         got\_data = 0;
659         \textcolor{keywordflow}{while} ( (pkt = \hyperlink{group__encoder_gae81cab25d66cf3bc59f1f75f8a5af720}{vpx\_codec\_get\_cx\_data}(&codec, &iter)) ) \{
660             got\_data = 1;
661             \textcolor{keywordflow}{switch} (pkt->\hyperlink{structvpx__codec__cx__pkt_a41f395b39516343c1329a4a85a0084f2}{kind}) \{
662             \textcolor{keywordflow}{case} \hyperlink{group__encoder_gga28a79375279536526552af3a83d2ed72a2261aae5594289400e812fb1e6b6b0cc}{VPX\_CODEC\_CX\_FRAME\_PKT}:
663                 \textcolor{keywordflow}{for} (i=cfg.\hyperlink{structvpx__codec__enc__cfg_a4d105d2470dbfb7210b33d298f1cf1f6}{ts\_layer\_id}[frame\_cnt % cfg.\hyperlink{structvpx__codec__enc__cfg_a4ec338780115dd270acf0dac24193474}{ts\_periodicity}];
664                                               i<cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}; i++)
665                 \{
666                     write\_ivf\_frame\_header(outfile[i], pkt);
667                     (void) fwrite(pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.\hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.buf, 1, pkt->\hyperlink{structvpx__codec__cx__pkt_a7f97b060a23b7e89fe5b885c0074f696}{data}.
      \hyperlink{structvpx__codec__cx__pkt_a81e33bf4408a3983abb16492fee359ff}{frame}.sz,
668                                   outfile[i]);
669                     frames\_in\_layer[i]++;
670                 \}
671                 \textcolor{keywordflow}{break};
672             \textcolor{keywordflow}{default}:
673                 \textcolor{keywordflow}{break};
674             \}
675         \}
676         frame\_cnt++;
677         pts += frame\_duration;
678     \}
679     fclose (infile);
680 
681     printf (\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"},frame\_cnt-1);
682     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6ae21d96909660d0ac978b59a863f53b}{vpx\_codec\_destroy}(&codec))
683             die\_codec (&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
684 
685     \textcolor{comment}{/* Try to rewrite the output file headers with the actual frame count */}
686     \textcolor{keywordflow}{for} (i=0; i<cfg.\hyperlink{structvpx__codec__enc__cfg_a16d4549a30cbd585e3c3056ef873d8c7}{ts\_number\_layers}; i++)
687     \{
688         \textcolor{keywordflow}{if} (!fseek(outfile[i], 0, SEEK\_SET))
689             write\_ivf\_file\_header (outfile[i], &cfg, frames\_in\_layer[i]);
690         fclose (outfile[i]);
691     \}
692 
693     \textcolor{keywordflow}{return} EXIT\_SUCCESS;
694 \}
\end{DoxyCodeInclude}
 \hypertarget{example_vp9_spatial_scalable_encoder}{}\subsection{vp9\+\_\+spatial\+\_\+scalable\+\_\+encoder}\label{example_vp9_spatial_scalable_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ *  Use of this source code is governed by a BSD-style license}
5 \textcolor{comment}{ *  that can be found in the LICENSE file in the root of the source}
6 \textcolor{comment}{ *  tree. An additional intellectual property rights grant can be found}
7 \textcolor{comment}{ *  in the file PATENTS.  All contributing project authors may}
8 \textcolor{comment}{ *  be found in the AUTHORS file in the root of the source tree.}
9 \textcolor{comment}{ */}
10 
11 \textcolor{comment}{/*}
12 \textcolor{comment}{ * This is an example demonstrating how to implement a multi-layer}
13 \textcolor{comment}{ * VP9 encoding scheme based on spatial scalability for video applications}
14 \textcolor{comment}{ * that benefit from a scalable bitstream.}
15 \textcolor{comment}{ */}
16 
17 \textcolor{preprocessor}{#include <stdarg.h>}
18 \textcolor{preprocessor}{#include <stdlib.h>}
19 \textcolor{preprocessor}{#include <string.h>}
20 \textcolor{preprocessor}{#include <time.h>}
21 \textcolor{preprocessor}{#include "./args.h"}
22 \textcolor{preprocessor}{#include "vpx/svc\_context.h"}
23 \textcolor{preprocessor}{#include "\hyperlink{vp8cx_8h}{vpx/vp8cx.h}"}
24 \textcolor{preprocessor}{#include "\hyperlink{vpx__encoder_8h}{vpx/vpx\_encoder.h}"}
25 
26 \textcolor{preprocessor}{#define VP90\_FOURCC 0x30395056}
27 
28 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list encoding\_mode\_enum[] = \{
29   \{\textcolor{stringliteral}{"i"}, INTER\_LAYER\_PREDICTION\_I\},
30   \{\textcolor{stringliteral}{"alt-ip"}, ALT\_INTER\_LAYER\_PREDICTION\_IP\},
31   \{\textcolor{stringliteral}{"ip"}, INTER\_LAYER\_PREDICTION\_IP\},
32   \{\textcolor{stringliteral}{"gf"}, USE\_GOLDEN\_FRAME\},
33   \{NULL, 0\}
34 \};
35 
36 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t encoding\_mode\_arg = ARG\_DEF\_ENUM(
37     \textcolor{stringliteral}{"m"}, \textcolor{stringliteral}{"encoding-mode"}, 1, \textcolor{stringliteral}{"Encoding mode algorithm"}, encoding\_mode\_enum);
38 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip\_frames\_arg =
39     ARG\_DEF(\textcolor{stringliteral}{"s"}, \textcolor{stringliteral}{"skip-frames"}, 1, \textcolor{stringliteral}{"input frames to skip"});
40 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frames\_arg =
41     ARG\_DEF(\textcolor{stringliteral}{"f"}, \textcolor{stringliteral}{"frames"}, 1, \textcolor{stringliteral}{"number of frames to encode"});
42 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width\_arg = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1, \textcolor{stringliteral}{"source width"});
43 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height\_arg = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1, \textcolor{stringliteral}{"source height"});
44 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase\_arg =
45     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"timebase"}, 1, \textcolor{stringliteral}{"timebase (num/den)"});
46 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bitrate\_arg = ARG\_DEF(
47     \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"target-bitrate"}, 1, \textcolor{stringliteral}{"encoding bitrate, in kilobits per second"});
48 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t layers\_arg =
49     ARG\_DEF(\textcolor{stringliteral}{"l"}, \textcolor{stringliteral}{"layers"}, 1, \textcolor{stringliteral}{"number of SVC layers"});
50 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_dist\_arg =
51     ARG\_DEF(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"kf-dist"}, 1, \textcolor{stringliteral}{"number of frames between keyframes"});
52 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scale\_factors\_arg =
53     ARG\_DEF(\textcolor{stringliteral}{"r"}, \textcolor{stringliteral}{"scale-factors"}, 1, \textcolor{stringliteral}{"scale factors (lowest to highest layer)"});
54 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quantizers\_arg =
55     ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quantizers"}, 1, \textcolor{stringliteral}{"quantizers (lowest to highest layer)"});
56 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dummy\_frame\_arg =
57     ARG\_DEF(\textcolor{stringliteral}{"z"}, \textcolor{stringliteral}{"dummy-frame"}, 1, \textcolor{stringliteral}{"make first frame blank and full size"});
58 
59 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *svc\_args[] = \{
60   &encoding\_mode\_arg, &frames\_arg,        &width\_arg,       &height\_arg,
61   &timebase\_arg,      &bitrate\_arg,       &skip\_frames\_arg, &layers\_arg,
62   &kf\_dist\_arg,       &scale\_factors\_arg, &quantizers\_arg,  &dummy\_frame\_arg,
63   NULL
64 \};
65 
66 \textcolor{keyword}{static} \textcolor{keyword}{const} SVC\_ENCODING\_MODE default\_encoding\_mode =
67     INTER\_LAYER\_PREDICTION\_IP;
68 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_frames\_to\_skip = 0;
69 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_frames\_to\_code = 60 * 60;
70 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_width = 1920;
71 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_height = 1080;
72 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_timebase\_num = 1;
73 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_timebase\_den = 60;
74 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_bitrate = 1000;
75 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_spatial\_layers = 5;
76 \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t default\_kf\_dist = 100;
77 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} default\_use\_dummy\_frame = 1;
78 
79 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
80   \textcolor{keywordtype}{char} *input\_filename;
81   \textcolor{keywordtype}{char} *output\_filename;
82   uint32\_t frames\_to\_code;
83   uint32\_t frames\_to\_skip;
84 \} AppInput;
85 
86 \textcolor{keyword}{static} \textcolor{keywordtype}{void} mem\_put\_le16(\textcolor{keywordtype}{char} *mem, uint32\_t val) \{
87   mem[0] = val;
88   mem[1] = val >> 8;
89 \}
90 
91 \textcolor{keyword}{static} \textcolor{keywordtype}{void} mem\_put\_le32(\textcolor{keywordtype}{char} *mem, uint32\_t val) \{
92   mem[0] = val;
93   mem[1] = val >> 8;
94   mem[2] = val >> 16;
95   mem[3] = val >> 24;
96 \}
97 
98 \textcolor{keyword}{static} \textcolor{keywordtype}{void} usage(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name) \{
99   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <options> input\_filename output\_filename\(\backslash\)n"},
100           exec\_name);
101   fprintf(stderr, \textcolor{stringliteral}{"Options:\(\backslash\)n"});
102   arg\_show\_usage(stderr, svc\_args);
103   exit(EXIT\_FAILURE);
104 \}
105 
106 \textcolor{keywordtype}{void} die(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
107   va\_list ap;
108 
109   va\_start(ap, fmt);
110   vfprintf(stderr, fmt, ap);
111   \textcolor{keywordflow}{if} (fmt[strlen(fmt) - 1] != \textcolor{charliteral}{'\(\backslash\)n'}) printf(\textcolor{stringliteral}{"\(\backslash\)n"});
112   exit(EXIT\_FAILURE);
113 \}
114 
115 \textcolor{keyword}{static} \textcolor{keywordtype}{void} die\_codec(\hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s) \{
116   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga29273cb552ed1a437fe263c4a0a54300}{vpx\_codec\_error\_detail}(ctx);
117 
118   printf(\textcolor{stringliteral}{"%s: %s\(\backslash\)n"}, s, \hyperlink{group__codec_ga4d265df00d42b36a4f0e3eb83fc22c5e}{vpx\_codec\_error}(ctx));
119   \textcolor{keywordflow}{if} (detail) printf(\textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
120   exit(EXIT\_FAILURE);
121 \}
122 
123 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(FILE *f, \hyperlink{structvpx__image}{vpx\_image\_t} *img) \{
124   \textcolor{keywordtype}{size\_t} nbytes;
125   \textcolor{keywordtype}{int} res = 1;
126   \textcolor{keywordtype}{int} plane;
127 
128   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
129     uint8\_t *ptr;
130     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = (plane ? (1 + img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w}) / 2 : img->\hyperlink{structvpx__image_a806bf23143bf00a0b3fdbd6ba030c483}{d\_w});
131     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = (plane ? (1 + img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h}) / 2 : img->\hyperlink{structvpx__image_a31bc5f045d4f3c2b6bb0f57bb53078e7}{d\_h});
132     \textcolor{keywordtype}{int} r;
133 
134     \textcolor{keywordflow}{switch} (plane) \{
135       \textcolor{keywordflow}{case} 1:
136         ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_a4770fc8fa60021a2229f25553152cf81}{VPX\_PLANE\_U}];
137         \textcolor{keywordflow}{break};
138       \textcolor{keywordflow}{case} 2:
139         ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[\hyperlink{vpx__image_8h_aca9436ec761457cc6d2e356e0ac2fd23}{VPX\_PLANE\_V}];
140         \textcolor{keywordflow}{break};
141       \textcolor{keywordflow}{default}:
142         ptr = img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[plane];
143     \}
144     \textcolor{keywordflow}{for} (r = 0; r < h; ++r) \{
145       \textcolor{keyword}{const} \textcolor{keywordtype}{int} to\_read = w;
146 
147       nbytes = fread(ptr, 1, to\_read, f);
148       \textcolor{keywordflow}{if} (nbytes != to\_read) \{
149         res = 0;
150         \textcolor{keywordflow}{if} (nbytes > 0)
151           printf(\textcolor{stringliteral}{"Warning: Read partial frame. Check your width & height!\(\backslash\)n"});
152         \textcolor{keywordflow}{break};
153       \}
154       ptr += img->\hyperlink{structvpx__image_ac9c7b83e3eea44cb680956f90dc789cf}{stride}[plane];
155     \}
156     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{break};
157   \}
158   \textcolor{keywordflow}{return} res;
159 \}
160 
161 \textcolor{keyword}{static} \textcolor{keywordtype}{int} create\_dummy\_frame(\hyperlink{structvpx__image}{vpx\_image\_t} *img) \{
162   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} buf\_size = img->\hyperlink{structvpx__image_ac7b7d569142f878155b28141653adcd6}{w} * img->\hyperlink{structvpx__image_a9d1070804dfe08cd5becd68d597fee69}{h} * 3 / 2;
163   memset(img->\hyperlink{structvpx__image_ab6258308ba7a5f4a113348120e20e2ce}{planes}[0], 129, buf\_size);
164   \textcolor{keywordflow}{return} 1;
165 \}
166 
167 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_file\_header(FILE *outfile,
168                                   uint32\_t width, uint32\_t height,
169                                   \textcolor{keywordtype}{int} timebase\_num, \textcolor{keywordtype}{int} timebase\_den,
170                                   \textcolor{keywordtype}{int} frame\_cnt) \{
171   \textcolor{keywordtype}{char} header[32];
172 
173   header[0] = \textcolor{charliteral}{'D'};
174   header[1] = \textcolor{charliteral}{'K'};
175   header[2] = \textcolor{charliteral}{'I'};
176   header[3] = \textcolor{charliteral}{'F'};
177   mem\_put\_le16(header + 4, 0);             \textcolor{comment}{/* version */}
178   mem\_put\_le16(header + 6, 32);            \textcolor{comment}{/* headersize */}
179   mem\_put\_le32(header + 8, VP90\_FOURCC);   \textcolor{comment}{/* fourcc */}
180   mem\_put\_le16(header + 12, width);        \textcolor{comment}{/* width */}
181   mem\_put\_le16(header + 14, height);       \textcolor{comment}{/* height */}
182   mem\_put\_le32(header + 16, timebase\_den); \textcolor{comment}{/* rate */}
183   mem\_put\_le32(header + 20, timebase\_num); \textcolor{comment}{/* scale */}
184   mem\_put\_le32(header + 24, frame\_cnt);    \textcolor{comment}{/* length */}
185   mem\_put\_le32(header + 28, 0);            \textcolor{comment}{/* unused */}
186 
187   (void)fwrite(header, 1, 32, outfile);
188 \}
189 
190 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_ivf\_frame\_header(FILE *outfile, \hyperlink{group__encoder_ga7e711b0a71c65aef8f0faea8bd57b05f}{vpx\_codec\_pts\_t} pts,
191                                    \textcolor{keywordtype}{size\_t} sz) \{
192   \textcolor{keywordtype}{char} header[12];
193   mem\_put\_le32(header, (uint32\_t)sz);
194   mem\_put\_le32(header + 4, pts & 0xFFFFFFFF);
195   mem\_put\_le32(header + 8, pts >> 32);
196 
197   (void)fwrite(header, 1, 12, outfile);
198 \}
199 
200 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_command\_line(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_,
201                                AppInput *app\_input, SvcContext *svc\_ctx,
202                                \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} *enc\_cfg) \{
203   \textcolor{keyword}{struct }arg arg;
204   \textcolor{keywordtype}{char} **argv, **argi, **argj;
205   \hyperlink{group__codec_gada1084710837ad363b92f2379dd2b8d2}{vpx\_codec\_err\_t} res;
206 
207   \textcolor{comment}{// initialize SvcContext with parameters that will be passed to vpx\_svc\_init}
208   svc\_ctx->log\_level = SVC\_LOG\_DEBUG;
209   svc\_ctx->spatial\_layers = default\_spatial\_layers;
210   svc\_ctx->encoding\_mode = default\_encoding\_mode;
211   \textcolor{comment}{// when using a dummy frame, that frame is only encoded to be full size}
212   svc\_ctx->first\_frame\_full\_size = default\_use\_dummy\_frame;
213 
214   \textcolor{comment}{// start with default encoder configuration}
215   res = \hyperlink{group__encoder_ga9ab8c79623312e9c5d5405d66a788f59}{vpx\_codec\_enc\_config\_default}(vpx\_codec\_vp9\_cx(), enc\_cfg, 0);
216   \textcolor{keywordflow}{if} (res) \{
217     die(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_gaaddf5c1f609ef18c7c8800d102fcefa6}{vpx\_codec\_err\_to\_string}(res));
218   \}
219   \textcolor{comment}{// update enc\_cfg with app default values}
220   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} = default\_width;
221   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} = default\_height;
222   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num} = default\_timebase\_num;
223   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den} = default\_timebase\_den;
224   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ab8339685175d66710f482706cc9f0aed}{rc\_target\_bitrate} = default\_bitrate;
225   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a0a7b5444ecb09745cbe8d5af17553846}{kf\_min\_dist} = default\_kf\_dist;
226   enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ae018440136e271743376730413d25a9b}{kf\_max\_dist} = default\_kf\_dist;
227 
228   \textcolor{comment}{// initialize AppInput with default values}
229   app\_input->frames\_to\_code = default\_frames\_to\_code;
230   app\_input->frames\_to\_skip = default\_frames\_to\_skip;
231 
232   \textcolor{comment}{// process command line options}
233   argv = argv\_dup(argc - 1, argv\_ + 1);
234   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
235     arg.argv\_step = 1;
236 
237     \textcolor{keywordflow}{if} (arg\_match(&arg, &encoding\_mode\_arg, argi)) \{
238       svc\_ctx->encoding\_mode = arg\_parse\_enum\_or\_int(&arg);
239     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &frames\_arg, argi)) \{
240       app\_input->frames\_to\_code = arg\_parse\_uint(&arg);
241     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width\_arg, argi)) \{
242       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} = arg\_parse\_uint(&arg);
243     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height\_arg, argi)) \{
244       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} = arg\_parse\_uint(&arg);
245     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height\_arg, argi)) \{
246       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} = arg\_parse\_uint(&arg);
247     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase\_arg, argi)) \{
248       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase} = arg\_parse\_rational(&arg);
249     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bitrate\_arg, argi)) \{
250       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ab8339685175d66710f482706cc9f0aed}{rc\_target\_bitrate} = arg\_parse\_uint(&arg);
251     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip\_frames\_arg, argi)) \{
252       app\_input->frames\_to\_skip = arg\_parse\_uint(&arg);
253     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &layers\_arg, argi)) \{
254       svc\_ctx->spatial\_layers = arg\_parse\_uint(&arg);
255     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_dist\_arg, argi)) \{
256       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a0a7b5444ecb09745cbe8d5af17553846}{kf\_min\_dist} = arg\_parse\_uint(&arg);
257       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ae018440136e271743376730413d25a9b}{kf\_max\_dist} = enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a0a7b5444ecb09745cbe8d5af17553846}{kf\_min\_dist};
258     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scale\_factors\_arg, argi)) \{
259       vpx\_svc\_set\_scale\_factors(svc\_ctx, arg.val);
260     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quantizers\_arg, argi)) \{
261       vpx\_svc\_set\_quantizers(svc\_ctx, arg.val);
262     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dummy\_frame\_arg, argi)) \{
263       svc\_ctx->first\_frame\_full\_size = arg\_parse\_int(&arg);
264     \} \textcolor{keywordflow}{else} \{
265       ++argj;
266     \}
267   \}
268 
269   \textcolor{comment}{// Check for unrecognized options}
270   \textcolor{keywordflow}{for} (argi = argv; *argi; ++argi)
271     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
272       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
273 
274   \textcolor{keywordflow}{if} (argv[0] == NULL || argv[1] == 0) \{
275     usage(argv\_[0]);
276   \}
277   app\_input->input\_filename = argv[0];
278   app\_input->output\_filename = argv[1];
279   free(argv);
280 
281   \textcolor{keywordflow}{if} (enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} < 16 || enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w} % 2 || enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} < 16 ||
282       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h} % 2)
283     die(\textcolor{stringliteral}{"Invalid resolution: %d x %d\(\backslash\)n"}, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h});
284 
285   printf(
286       \textcolor{stringliteral}{"Codec %s\(\backslash\)nframes: %d, skip: %d\(\backslash\)n"}
287       \textcolor{stringliteral}{"mode: %d, layers: %d\(\backslash\)n"}
288       \textcolor{stringliteral}{"width %d, height: %d,\(\backslash\)n"}
289       \textcolor{stringliteral}{"num: %d, den: %d, bitrate: %d,\(\backslash\)n"}
290       \textcolor{stringliteral}{"gop size: %d, use\_dummy\_frame: %d\(\backslash\)n"},
291       \hyperlink{group__codec_ga9eee39f450d8cdcf5aba0e2bda6e5aa8}{vpx\_codec\_iface\_name}(vpx\_codec\_vp9\_cx()), app\_input->frames\_to\_code,
292       app\_input->frames\_to\_skip, svc\_ctx->encoding\_mode,
293       svc\_ctx->spatial\_layers, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h},
294       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num}, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den},
295       enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ab8339685175d66710f482706cc9f0aed}{rc\_target\_bitrate}, enc\_cfg->\hyperlink{structvpx__codec__enc__cfg_ae018440136e271743376730413d25a9b}{kf\_max\_dist},
296       svc\_ctx->first\_frame\_full\_size);
297 \}
298 
299 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv) \{
300   AppInput app\_input = \{0\};
301   FILE *infile, *outfile;
302   \hyperlink{structvpx__codec__ctx}{vpx\_codec\_ctx\_t} codec;
303   \hyperlink{structvpx__codec__enc__cfg}{vpx\_codec\_enc\_cfg\_t} enc\_cfg;
304   SvcContext svc\_ctx;
305   uint32\_t i;
306   uint32\_t frame\_cnt = 0;
307   \hyperlink{structvpx__image}{vpx\_image\_t} raw;
308   \hyperlink{group__codec_gada1084710837ad363b92f2379dd2b8d2}{vpx\_codec\_err\_t} res;
309   \textcolor{keywordtype}{int} pts = 0;            \textcolor{comment}{/* PTS starts at 0 */}
310   \textcolor{keywordtype}{int} frame\_duration = 1; \textcolor{comment}{/* 1 timebase tick per frame */}
311 
312   memset(&svc\_ctx, 0, \textcolor{keyword}{sizeof}(svc\_ctx));
313   svc\_ctx.log\_print = 1;
314   parse\_command\_line(argc, argv, &app\_input, &svc\_ctx, &enc\_cfg);
315 
316   \textcolor{comment}{// Allocate image buffer}
317   \textcolor{keywordflow}{if} (!\hyperlink{vpx__image_8h_ab80398f28ca880368a922fa979eb66c1}{vpx\_img\_alloc}(&raw, \hyperlink{vpx__image_8h_a7a30a7bff7400fb83ad45fede5077193af17ce49c9a6efd7c8c8ea8928d4ce26c}{VPX\_IMG\_FMT\_I420}, enc\_cfg.
      \hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h}, 32))
318     die(\textcolor{stringliteral}{"Failed to allocate image %dx%d\(\backslash\)n"}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h});
319 
320   \textcolor{keywordflow}{if} (!(infile = fopen(app\_input.input\_filename, \textcolor{stringliteral}{"rb"})))
321     die(\textcolor{stringliteral}{"Failed to open %s for reading\(\backslash\)n"}, app\_input.input\_filename);
322 
323   \textcolor{keywordflow}{if} (!(outfile = fopen(app\_input.output\_filename, \textcolor{stringliteral}{"wb"})))
324     die(\textcolor{stringliteral}{"Failed to open %s for writing\(\backslash\)n"}, app\_input.output\_filename);
325 
326   \textcolor{comment}{// Initialize codec}
327   \textcolor{keywordflow}{if} (vpx\_svc\_init(&svc\_ctx, &codec, vpx\_codec\_vp9\_cx(), &enc\_cfg) !=
328       \hyperlink{group__codec_ggada1084710837ad363b92f2379dd2b8d2af1dcde74b1c5ff7b29f31246dfd90986}{VPX\_CODEC\_OK})
329     die(\textcolor{stringliteral}{"Failed to initialize encoder\(\backslash\)n"});
330 
331   write\_ivf\_file\_header(outfile, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h},
332                         enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.
      \hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den}, 0);
333 
334   \textcolor{comment}{// skip initial frames}
335   \textcolor{keywordflow}{for} (i = 0; i < app\_input.frames\_to\_skip; ++i) \{
336     read\_frame(infile, &raw);
337   \}
338 
339   \textcolor{comment}{// Encode frames}
340   \textcolor{keywordflow}{while} (frame\_cnt <= app\_input.frames\_to\_code) \{
341     \textcolor{keywordflow}{if} (frame\_cnt == 0 && svc\_ctx.first\_frame\_full\_size) \{
342       create\_dummy\_frame(&raw);
343     \} \textcolor{keywordflow}{else} \{
344       \textcolor{keywordflow}{if} (!read\_frame(infile, &raw)) \textcolor{keywordflow}{break};
345     \}
346     res = vpx\_svc\_encode(&svc\_ctx, &codec, &raw, pts, frame\_duration,
347                          \hyperlink{group__encoder_ga04253cc9ec1146d72fa8bb86bcf32144}{VPX\_DL\_REALTIME});
348     printf(\textcolor{stringliteral}{"%s"}, vpx\_svc\_get\_message(&svc\_ctx));
349     \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggada1084710837ad363b92f2379dd2b8d2af1dcde74b1c5ff7b29f31246dfd90986}{VPX\_CODEC\_OK}) \{
350       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode frame"});
351     \}
352     \textcolor{keywordflow}{if} (vpx\_svc\_get\_frame\_size(&svc\_ctx) > 0) \{
353       write\_ivf\_frame\_header(outfile, pts, vpx\_svc\_get\_frame\_size(&svc\_ctx));
354       (void)fwrite(vpx\_svc\_get\_buffer(&svc\_ctx), 1,
355                    vpx\_svc\_get\_frame\_size(&svc\_ctx), outfile);
356     \}
357     ++frame\_cnt;
358     pts += frame\_duration;
359   \}
360 
361   printf(\textcolor{stringliteral}{"Processed %d frames\(\backslash\)n"}, frame\_cnt - svc\_ctx.first\_frame\_full\_size);
362 
363   fclose(infile);
364   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6ae21d96909660d0ac978b59a863f53b}{vpx\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
365 
366   \textcolor{comment}{// rewrite the output file headers with the actual frame count}
367   \textcolor{keywordflow}{if} (!fseek(outfile, 0, SEEK\_SET)) \{
368     write\_ivf\_file\_header(outfile, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a5c165f5b41ca1158f2883983a2b7709c}{g\_w}, enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a4132bd89ce85bce7c08f2cc3b6f2b82e}{g\_h},
369                           enc\_cfg.\hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_ae7774f21a22c9bef3aa73156c79f4731}{num}, enc\_cfg.
      \hyperlink{structvpx__codec__enc__cfg_a6498d378e4c29ef3e22258289e481087}{g\_timebase}.\hyperlink{structvpx__rational_a29dd2ab4001377b3aa21885ef969759f}{den},
370                           frame\_cnt);
371   \}
372   fclose(outfile);
373   \hyperlink{vpx__image_8h_af47ebaf286812d037425d41990d48a17}{vpx\_img\_free}(&raw);
374 
375   \textcolor{comment}{// display average size, psnr}
376   printf(\textcolor{stringliteral}{"%s"}, vpx\_svc\_dump\_statistics(&svc\_ctx));
377 
378   vpx\_svc\_release(&svc\_ctx);
379 
380   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
381 \}
\end{DoxyCodeInclude}
 